{"meta":{"title":"YNCBearz","subtitle":"","description":"","author":"YNCBearz","url":"https://yncbearz.github.io","root":"/"},"pages":[{"title":"","date":"2020-07-30T15:51:20.748Z","updated":"2020-07-30T15:51:20.748Z","comments":true,"path":"manifest.json","permalink":"https://yncbearz.github.io/manifest.json","excerpt":"","text":"{\"name\":\"YNCBearz\",\"short_name\":\"YNCBearz\",\"theme_color\":\"#202124\",\"background_color\":\"#202124\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/image/icons/512x512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"},{\"src\":\"/image/icons/192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/image/icons/white-bg/180x180.png\",\"sizes\":\"180x180\",\"type\":\"image/png\"},{\"src\":\"/image/icons/white-bg/144x144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/image/icons/white-bg/128x128.png\",\"sizes\":\"128x128\",\"type\":\"image/png\"},{\"src\":\"/image/icons/white-bg/96x96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"/image/icons/white-bg/48x48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2020-07-27T15:47:39.102Z","updated":"2020-07-27T15:47:39.102Z","comments":true,"path":"sw.js","permalink":"https://yncbearz.github.io/sw.js","excerpt":"","text":"importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js'); if (workbox) { workbox.setConfig({ modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' }); workbox.precaching.precache(['/', '/index.html']); workbox.routing.registerRoute(new RegExp('^https?://yncbearz.github.io/?$'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.(?:js|css|jpg|png|gif)'), workbox.strategies.staleWhileRevalidate()); }"},{"title":"Page Not Found","date":"2020-10-17T10:49:40.000Z","updated":"2020-10-17T11:28:57.158Z","comments":false,"path":"/404.html","permalink":"https://yncbearz.github.io/404.html","excerpt":"","text":"1234567891011121314151617181920212223# _oo0oo_# o8888888o# 88\" . \"88# (| -_- |)# 0\\ = /0# ___/`---'\\___# .' \\\\| |// '.# / \\\\||| : |||// \\# / _||||| -:- |||||- \\# | | \\\\\\ - /// | |# | \\_| ''\\---/'' |_/ |# \\ .-\\__ '-' ___/-. /# ___'. .' /--.--\\ `. .'___# .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;' \"\".# | | : `- \\`.;`\\ _ /`;.`/ - ` : | |# \\ \\ `_. \\_ __\\ /__ _/ .-` / /# =====`-.____`.___ \\_____/___.-`___.-'=====# `=---='### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~## 佛曰：靜下心來，自然看不到bug 看來你是迷路了。稍微深呼吸一下。 預計在約 秒後就會返回首頁。 ʕ •ᴥ•ʔ：如果你很急著想看文章，也可以 點這裡 返回首頁。 let countTime = 6; function count() { document.getElementById('timeout').textContent = countTime; countTime -= 1; if(countTime === 0){ location.href = 'https://yncbearz.github.io/'; } setTimeout(() => { count(); }, 1000); } count();"},{"title":"","date":"2021-07-14T15:27:49.198Z","updated":"2021-07-14T15:27:49.198Z","comments":true,"path":"about/index.html","permalink":"https://yncbearz.github.io/about/index.html","excerpt":"","text":"ʕ •ᴥ•ʔ：保持心情愉快PHP工程師 / 數學系。 誤打誤撞來到這行，才發覺是條不歸路（咦） [Usage history of my editor] Vistual Studio Code Vistual Studio Code + extension Try to use Vim and gave up after one day.(Reason: not adapted to) Vistual Studio Code + extension + shortcut Vistual Studio Code (feat. VSCodeVim) Try to use Vim and gave up after one week.(Reason: need to spend lots of time to make good user interface) PHPStorm (feat. Ideavim) PHPStorm (feat. Ideavim) + custom .ideavimrc + custom shortcut ʕ •ᴥ•ʔ：Feel comfortable in coding now."}],"posts":[{"title":"107.binary-tree-level-order-traversal-ii","slug":"107-binary-tree-level-order-traversal-ii","date":"2021-04-22T15:55:42.000Z","updated":"2021-04-22T16:54:51.532Z","comments":true,"path":"2021/04/22/107-binary-tree-level-order-traversal-ii/","link":"","permalink":"https://yncbearz.github.io/2021/04/22/107-binary-tree-level-order-traversal-ii/","excerpt":"107.binary-tree-level-order-traversal-ii","text":"Description:Given the root of a binary tree, return the bottom-up level order traversal of its nodes’ values. (i.e., from left to right, level by level from leaf to root).Example: 12345678Input: root &#x3D; [3,9,20,null,null,15,7] 3 &#x2F; \\ 9 20 &#x2F; \\ 15 7Output: [[15,7],[9,20],[3]] 12Input: root &#x3D; [1]Output: [[1]] 12Input: root &#x3D; []Output: [] 深度優先搜尋 (Depth-First Search, DFS)搜尋頂點時，先探查單一路線，直到無法繼續前進，再折返探查下一個選項路徑。過程中，因展開而得到的頂點選項，可利用堆疊 (Stack) 的資料結構。 廣度優先搜尋 (Breadth-First Search, BFS)搜尋頂點時，從起點經由邊搜尋頂點，直到找到指定的頂點。過程中，因展開而得到的頂點選項，可利用佇列 (Queue) 的資料結構。 First Answer (DFS): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpnamespace LeetCode\\BinaryTreeLevelOrderTraversalII;/** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($val = 0, $left = null, $right = null) &#123; * $this-&gt;val = $val; * $this-&gt;left = $left; * $this-&gt;right = $right; * &#125; * &#125; */class Solution&#123; /** * @var array */ protected $answer = []; /** * @param TreeNode $root * @return Integer[][] */ public function levelOrderBottom($root) &#123; if (is_null($root-&gt;val)) &#123; return []; &#125; $this-&gt;findAnswer($root); $this-&gt;reverse(); return $this-&gt;answer; &#125; /** * @param TreeNode $root * @param int $level */ private function findAnswer($root, $level = 0) &#123; if (is_null($root-&gt;val)) &#123; return; &#125; $this-&gt;answer[$level] = array_merge($this-&gt;answer[$level] ?? [], [$root-&gt;val]); $this-&gt;findAnswer($root-&gt;left, $level + 1); $this-&gt;findAnswer($root-&gt;right, $level + 1); &#125; private function reverse() &#123; $this-&gt;answer = array_reverse($this-&gt;answer); &#125;&#125; Other Answer (BFS): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpnamespace LeetCode\\BinaryTreeLevelOrderTraversalII;/** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($val = 0, $left = null, $right = null) &#123; * $this-&gt;val = $val; * $this-&gt;left = $left; * $this-&gt;right = $right; * &#125; * &#125; */class Solution&#123; /** * @var array */ protected $answer = []; /** * @param TreeNode $root * @return Integer[][] */ public function levelOrderBottom($root) &#123; if (is_null($root-&gt;val)) &#123; return []; &#125; $this-&gt;answer[0] = [$root-&gt;val]; $this-&gt;findAnswer($root); $this-&gt;reverse(); return $this-&gt;answer; &#125; /** * @param TreeNode $root */ private function findAnswer($root, $level = 1) &#123; if (is_null($root-&gt;val)) &#123; return; &#125; if (!is_null($root-&gt;left)) &#123; $this-&gt;answer[$level] = array_merge($this-&gt;answer[$level] ?? [], [$root-&gt;left-&gt;val]); &#125; if (!is_null($root-&gt;right)) &#123; $this-&gt;answer[$level] = array_merge($this-&gt;answer[$level] ?? [], [$root-&gt;right-&gt;val]); &#125; $this-&gt;findAnswer($root-&gt;left, $level + 1); $this-&gt;findAnswer($root-&gt;right, $level + 1); &#125; private function reverse() &#123; $this-&gt;answer = array_reverse($this-&gt;answer); &#125;&#125; ʕ •ᴥ•ʔ：欣賞一下 DFS 和 BFS 思考上的不同。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://yncbearz.github.io/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yncbearz.github.io/tags/LeetCode/"}]},{"title":"101.symmetric-tree","slug":"101-symmetric-tree","date":"2021-04-11T15:31:42.000Z","updated":"2021-04-11T15:54:09.668Z","comments":true,"path":"2021/04/11/101-symmetric-tree/","link":"","permalink":"https://yncbearz.github.io/2021/04/11/101-symmetric-tree/","excerpt":"101.symmetric-tree","text":"Description:Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).Example: 12345678Input: root &#x3D; [1,2,2,3,4,4,3] 1 &#x2F; \\ 2 2 &#x2F; \\ &#x2F; \\ 3 4 4 3Output: true 12345678Input: root &#x3D; [1,2,2,null,3,null,3] 1 &#x2F; \\ 2 2 \\ \\ 3 3Output: false Follow up: Could you solve it both recursively and iteratively? Similar Question: 94.binary-tree-inorder-traversal First Answer (Recursive): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?phpnamespace LeetCode\\SymmetricTree;/** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($val = 0, $left = null, $right = null) &#123; * $this-&gt;val = $val; * $this-&gt;left = $left; * $this-&gt;right = $right; * &#125; * &#125; */class Solution&#123; /** * @var bool */ protected $answer = true; /** * @param TreeNode $root * @return bool */ public function isSymmetric($root) &#123; if (is_null($root-&gt;val)) &#123; return true; &#125; if (is_null($root-&gt;left) &amp;&amp; is_null($root-&gt;right)) &#123; return true; &#125; $this-&gt;checkSysmmetric($root-&gt;left, $root-&gt;right); return $this-&gt;answer; &#125; /** * @param TreeNode $leftTree * @param TreeNode $rightTree */ private function checkSysmmetric($leftTree, $rightTree) &#123; if ($leftTree-&gt;val !== $rightTree-&gt;val) &#123; return $this-&gt;answer = false; &#125; if ( $leftTree-&gt;left instanceof TreeNode &amp;&amp; $rightTree-&gt;right instanceof TreeNode ) &#123; $this-&gt;checkSysmmetric($leftTree-&gt;left, $rightTree-&gt;right); &#125; if ( $leftTree-&gt;right instanceof TreeNode &amp;&amp; $rightTree-&gt;left instanceof TreeNode ) &#123; $this-&gt;checkSysmmetric($leftTree-&gt;right, $rightTree-&gt;left); &#125; if ($this-&gt;isNullAmountOdd($leftTree-&gt;left, $rightTree-&gt;right)) &#123; return $this-&gt;answer = false; &#125; if ($this-&gt;isNullAmountOdd($leftTree-&gt;right, $rightTree-&gt;left)) &#123; return $this-&gt;answer = false; &#125; &#125; /** * @param TreeNode|null $a * @param TreeNode|null $b * @return bool */ private function isNullAmountOdd($a, $b) &#123; $nullAmount = 0; if (is_null($a)) &#123; $nullAmount++; &#125; if (is_null($b)) &#123; $nullAmount++; &#125; return ($nullAmount % 2 == 1); &#125;&#125; Time Complexity: O(n) Other Answer (Iterating + Stack): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpnamespace LeetCode\\SymmetricTree;/** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($val = 0, $left = null, $right = null) &#123; * $this-&gt;val = $val; * $this-&gt;left = $left; * $this-&gt;right = $right; * &#125; * &#125; */class Solution&#123; /** * @var array */ protected $stack = []; /** * @param TreeNode $root * @return bool */ public function isSymmetric($root) &#123; if (is_null($root-&gt;val)) &#123; return true; &#125; $this-&gt;stack[] = [$root-&gt;left, $root-&gt;right]; while (count($this-&gt;stack) &gt; 0) &#123; $pop = array_pop($this-&gt;stack); $left = $pop[0]; $right = $pop[1]; if (is_null($left) &amp;&amp; is_null($right)) &#123; continue; &#125; if (is_null($left) || is_null($right)) &#123; return false; &#125; if ($left-&gt;val == $right-&gt;val) &#123; $this-&gt;stack[] = [$left-&gt;left, $right-&gt;right]; $this-&gt;stack[] = [$left-&gt;right, $right-&gt;left]; &#125; else &#123; return false; &#125; &#125; return true; &#125;&#125; Time Complexity: O(n) ʕ •ᴥ•ʔ：Iterating的作法，有體會到要利用Stack當存檔點，但具體的while條件沒有想出來。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://yncbearz.github.io/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yncbearz.github.io/tags/LeetCode/"}]},{"title":"100.same-tree","slug":"100-same-tree","date":"2021-04-10T09:18:39.000Z","updated":"2021-04-11T15:53:38.967Z","comments":true,"path":"2021/04/10/100-same-tree/","link":"","permalink":"https://yncbearz.github.io/2021/04/10/100-same-tree/","excerpt":"100.same-tree","text":"Description:Given the roots of two binary trees p and q, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.Example: 123456Input: p &#x3D; [1,2,3], q &#x3D; [1,2,3] 1 1 &#x2F; \\ &#x2F; \\ 2 3 2 3Output: true 123456Input: p &#x3D; [1,2], q &#x3D; [1,null,2] 1 1 &#x2F; \\ 2 2Output: false 123456Input: p &#x3D; [1,2,1], q &#x3D; [1,1,2] 1 1 &#x2F; \\ &#x2F; \\ 2 1 1 2Output: false First Answer (Recursive): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpnamespace LeetCode\\SameTree;/** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($val = 0, $left = null, $right = null) &#123; * $this-&gt;val = $val; * $this-&gt;left = $left; * $this-&gt;right = $right; * &#125; * &#125; */class Solution&#123; /** * @var bool $answer */ protected $answer = true; /** * @param TreeNode $p * @param TreeNode $q * @return bool */ public function isSameTree($p, $q) &#123; $this-&gt;findAnswer($p, $q); return $this-&gt;answer; &#125; /** * @param TreeNode $p * @param TreeNode $q */ private function findAnswer($p, $q) &#123; if ($p-&gt;val !== $q-&gt;val) &#123; return $this-&gt;answer = false; &#125; if (($p-&gt;left-&gt;val !== $q-&gt;left-&gt;val) || ($p-&gt;right-&gt;val !== $q-&gt;right-&gt;val)) &#123; return $this-&gt;answer = false; &#125; if (!is_null($p-&gt;left) &amp;&amp; !is_null($q-&gt;left)) &#123; $this-&gt;findAnswer($p-&gt;left, $q-&gt;left); &#125; if (!is_null($p-&gt;right) &amp;&amp; !is_null($q-&gt;right)) &#123; $this-&gt;findAnswer($p-&gt;right, $q-&gt;right); &#125; &#125;&#125; Time Complexity: O(n) ʕ •ᴥ•ʔ：很久沒寫文了，最近覺得情況不算太好。重新努力，用寫文把狀態找回來。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://yncbearz.github.io/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yncbearz.github.io/tags/LeetCode/"}]},{"title":"95.unique-binary-search-trees-ii","slug":"95-unique-binary-search-trees-ii","date":"2021-01-22T13:46:43.000Z","updated":"2021-04-10T07:29:05.662Z","comments":true,"path":"2021/01/22/95-unique-binary-search-trees-ii/","link":"","permalink":"https://yncbearz.github.io/2021/01/22/95-unique-binary-search-trees-ii/","excerpt":"95.unique-binary-search-trees-ii","text":"Description:Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.Example: 1234567891011121314151617Input: 3Output:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST&#39;s shown below: 1 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\ 2 1 2 3 Similar Question: 96.unique-binary-search-trees Note.Binary Search Tree: Key(L)&lt;Key(Current)&lt;Key(R) Appropriate Answer (Divide-and-conquer): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?phpnamespace LeetCode\\UniqueBinarySearchTreesII;/** * Definition for a binary tree node. */// class TreeNode// &#123;// public $val = null;// public $left = null;// public $right = null;// function __construct($val = 0, $left = null, $right = null)// &#123;// $this-&gt;val = $val;// $this-&gt;left = $left;// $this-&gt;right = $right;// &#125;// &#125;class Solution&#123; /** * @param int $n * @return TreeNode[] */ public function generateTrees($n) &#123; $numbers = range(1, $n); return $this-&gt;generateTreesByNumbers($numbers); &#125; /** * @param int[] $originalNumbers * @return array */ private function generateTreesByNumbers($originalNumbers) &#123; if (count($originalNumbers) == 0) &#123; return [null]; &#125; if (count($originalNumbers) == 1) &#123; return [new TreeNode(array_pop($originalNumbers))]; &#125; $result = []; //[1,2,3] =&gt; (1, [2,3]) (2, [1,3]) (3, [1,2]) foreach ($originalNumbers as $key =&gt; $val) &#123; $currentNumbers = $originalNumbers; unset($currentNumbers[$key]); $otherNumbers = $currentNumbers; $result = array_merge($result, $this-&gt;binarySearch($val, $otherNumbers)); &#125; return $result; &#125; /** * @param int $val * @param int[] $otherNumbers * @return TreeNode[] */ private function binarySearch($val, $otherNumbers) &#123; $smallerNumbers = array_filter($otherNumbers, function ($otherNumber) use ($val) &#123; return $otherNumber &lt; $val; &#125;); $biggerNumbers = array_filter($otherNumbers, function ($otherNumber) use ($val) &#123; return $otherNumber &gt; $val; &#125;); $smallerTrees = $this-&gt;generateTreesByNumbers($smallerNumbers); $biggerTrees = $this-&gt;generateTreesByNumbers($biggerNumbers); $trees = []; foreach ($smallerTrees as $aSmallerTree) &#123; foreach ($biggerTrees as $aBiggerTree) &#123; $tree = new TreeNode($val, $aSmallerTree, $aBiggerTree); $trees[] = $tree; &#125; &#125; return $trees; &#125;&#125; ʕ •ᴥ•ʔ：由 linsheng 提供的解法。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://yncbearz.github.io/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yncbearz.github.io/tags/LeetCode/"}]},{"title":"96.unique-binary-search-trees","slug":"96-unique-binary-search-trees","date":"2021-01-14T15:23:38.000Z","updated":"2021-01-14T15:37:17.592Z","comments":true,"path":"2021/01/14/96-unique-binary-search-trees/","link":"","permalink":"https://yncbearz.github.io/2021/01/14/96-unique-binary-search-trees/","excerpt":"96.unique-binary-search-trees","text":"Description:Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?Example: 12345678910Input: 3Output: 5Explanation:Given n &#x3D; 3, there are a total of 5 unique BST&#39;s: 1 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\ 2 1 2 3 Appropriate Answer (Dynamic Programming): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpnamespace LeetCode\\UniqueBinarySearchTrees;class Solution&#123; /** * @var array */ private $numOfAnswer = []; /** * @param int $n * @return int */ public function numTrees($n) &#123; /** * 沒有節點的情況有一種可能（空集合） */ $this-&gt;numOfAnswer[0] = 1; /** * 1個節點的情況有一種可能（一個點） */ $this-&gt;numOfAnswer[1] = 1; for ($i = 2; $i &lt;= $n; $i++) &#123; $this-&gt;count($i); &#125; return $this-&gt;numOfAnswer[$n]; &#125; /** * @param int $n * @return void */ private function count($n) &#123; /** * 先取出一個節點當root */ $num = $n - 1; /** * 1. 左節點的數量 + 右節點的數量 = $num * 2. 總和 = 左節點數量的所有可能 * 右節點數量的所有可能 */ $result = 0; for ($i = 0; $i &lt;= $num; $i++) &#123; $result = $result + $this-&gt;numOfAnswer[$i] * $this-&gt;numOfAnswer[$num - $i]; &#125; $this-&gt;numOfAnswer[$n] = $result; &#125;&#125; Time Complexity: O(n) ʕ •ᴥ•ʔ：DP Program的思考方式還須多多練習。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://yncbearz.github.io/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yncbearz.github.io/tags/LeetCode/"}]},{"title":"94.binary-tree-inorder-traversal","slug":"94-binary-tree-inorder-traversal","date":"2021-01-02T15:01:19.000Z","updated":"2021-04-22T16:18:27.456Z","comments":true,"path":"2021/01/02/94-binary-tree-inorder-traversal/","link":"","permalink":"https://yncbearz.github.io/2021/01/02/94-binary-tree-inorder-traversal/","excerpt":"94.binary-tree-inorder-traversal","text":"Description:Given a binary tree, return the inorder traversal of its nodes’ values.Example: 12345678Input: [1,null,2,3] 1 \\ 2 &#x2F; 3Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? 說明： 12345 4 &#x2F; \\ 2 6 &#x2F; \\ &#x2F; \\1 3 5 7 遍歷方式 輸出結果 搜尋演算法 Pre-Order Traversal 4213657 Depth-first Search In-Order Traversal 1234567 Depth-first Search Post-Order Traversal 1325764 Depth-first Search Level-Order Traversal 4261357 Breadth-first Search Pre-, In-, Post- 是指parent node相對於child node的順序。而Level-則是依照層級關係。 First Answer (Recursive): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace LeetCode\\BinaryTreeInorderTraversal;/** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($value) &#123; $this-&gt;val = $value; &#125; * &#125; */class Solution&#123; /** * @var Integer[] */ protected $answer = []; /** * @param TreeNode $root * @return Integer[] */ public function inorderTraversal($root) &#123; $this-&gt;findAnswer($root); return $this-&gt;answer; &#125; /** * @param TreeNode $root */ private function findAnswer($root) &#123; /** * 先把左子樹找完 */ if (!is_null($root-&gt;left)) &#123; $this-&gt;findAnswer($root-&gt;left); &#125; /** * 沒有左子樹後，填入根（自己） */ $this-&gt;answer[] = $root-&gt;val; /** * 再找右子樹 */ if (!is_null($root-&gt;right)) &#123; $this-&gt;findAnswer($root-&gt;right); &#125; &#125;&#125; Time Complexity: O(n) Other Answer (Iterating + Stack): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace LeetCode\\BinaryTreeInorderTraversal;/** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($value) &#123; $this-&gt;val = $value; &#125; * &#125; */class Solution&#123; /** * @var Integer[] */ protected $answer = []; /** * @var Integer[] */ protected $stack = []; /** * @param TreeNode $root * @return Integer[] */ public function inorderTraversal($root) &#123; $this-&gt;findAnswer($root); return $this-&gt;answer; &#125; /** * @param TreeNode $root */ private function findAnswer($root) &#123; while (count($this-&gt;stack) &gt; 0 || !is_null($root)) &#123; if (!is_null($root)) &#123; $this-&gt;stack[] = $root; $root = $root-&gt;left; &#125; else &#123; $pop = array_pop($this-&gt;stack); $this-&gt;answer[] = $pop-&gt;val; if (!is_null($pop-&gt;right)) &#123; $root = $pop-&gt;right; &#125; &#125; &#125; &#125;&#125; Time Complexity: O(n) ʕ •ᴥ•ʔ：還有看到一種Morris Traversal的方法，之後遇到再補充。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://yncbearz.github.io/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yncbearz.github.io/tags/LeetCode/"}]},{"title":"小筆記：Exists 與 Not Exists","slug":"Note-Exists-And-Not-Exists","date":"2021-01-01T08:01:54.000Z","updated":"2021-01-01T12:40:42.818Z","comments":true,"path":"2021/01/01/Note-Exists-And-Not-Exists/","link":"","permalink":"https://yncbearz.github.io/2021/01/01/Note-Exists-And-Not-Exists/","excerpt":"Note-Exists-And-Not-Exists","text":"本篇靈感來源：SQL達人的工作現場攻略筆記 本書提到的兩張資料表： 原題目如下：今日欲從emp_skills表中，挑出會所有skills表上技能的員工。 這邊想記錄幾個 exists 跟 not exists 語法的效果。 情況一 12345678910111213141516171819SELECT *FROM emp_skills AS AWHERE EXISTS ( SELECT * FROM skills C WHERE EXISTS ( SELECT * FROM emp_skills AS B WHERE (A.emp = B.emp) AND (B.skill = C.skill) )); 效果是，找出至少會一個skills表上技能的員工。因此靚儀會被去除。 Hint: 把每個人會的技能組當成一個集合。 情況二 12345678910111213141516171819SELECT *FROM emp_skills AS AWHERE NOT EXISTS ( SELECT * FROM skills C WHERE EXISTS ( SELECT * FROM emp_skills AS B WHERE (A.emp = B.emp) AND (B.skill = C.skill) )); 效果是，找出skills表上技能一個都不會的員工。因此只有靚儀會被選出。 情況三 12345678910111213141516171819SELECT *FROM emp_skills AS AWHERE EXISTS ( SELECT * FROM skills C WHERE NOT EXISTS ( SELECT * FROM emp_skills AS B WHERE (A.emp = B.emp) AND (B.skill = C.skill) )); 效果是，找出沒有全會skills表上技能的員工。因此銘仁、靜儀、勝朋皆會被選出。 情況四 12345678910111213141516171819SELECT *FROM emp_skills AS AWHERE NOT EXISTS ( SELECT * FROM skills C WHERE NOT EXISTS ( SELECT * FROM emp_skills AS B WHERE (A.emp = B.emp) AND (B.skill = C.skill) )); 在理解情況三後，這邊的效果就很明顯了。找出會所有skills表上技能的員工。 最後附上原題目的NOT EXISTS解法。 由 Zero 提供 12345678910111213141516171819SELECT DISTINCT empFROM emp_skills AS AWHERE NOT EXISTS ( SELECT * FROM skills C WHERE NOT EXISTS ( SELECT * FROM emp_skills AS B WHERE (A.emp = B.emp) AND (B.skill = C.skill) )); 即修改SELECT中欄位值的情況四。 ʕ •ᴥ•ʔ：Zero真是SQL大神～","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://yncbearz.github.io/tags/Note/"},{"name":"SQL","slug":"SQL","permalink":"https://yncbearz.github.io/tags/SQL/"}]},{"title":"類別圖：各國婚禮（訪問者模式）","slug":"Class-Diagram-Wedding-Visitor-Pattern","date":"2020-12-27T08:37:14.000Z","updated":"2020-12-27T13:20:04.341Z","comments":true,"path":"2020/12/27/Class-Diagram-Wedding-Visitor-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/12/27/Class-Diagram-Wedding-Visitor-Pattern/","excerpt":"Class Diagram:Wedding (Visitor Pattern)","text":"Example: 各國婚禮 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：各國婚禮（訪問者模式）","slug":"Example-Wedding-Visitor-Pattern","date":"2020-12-27T08:36:50.000Z","updated":"2020-12-27T10:09:10.012Z","comments":true,"path":"2020/12/27/Example-Wedding-Visitor-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/12/27/Example-Wedding-Visitor-Pattern/","excerpt":"Example-Wedding-Visitor-Pattern","text":"Pattern: 訪問者模式 Class Diagram: 各國婚禮 \b情境：這是一間國際婚禮公司 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\\VisitorPattern\\Wedding;class Program&#123; /** * @param string $weddingType * @return string */ public function getWedding($weddingType) &#123; switch ($weddingType) &#123; case 'Chinese': echo '新郎：中式囍袍新郎：黑色秀禾鞋新娘：龍鳳褂新娘：紅色秀禾鞋'; break; case 'Japanese': echo '新郎：繡有家紋的和服新郎：雪駄新娘：純潔的白無垢新娘：草履'; break; &#125; &#125;&#125; 熟稔設計模式的我們，一眼就看出來改寫的方向。 讓我們抽出新郎與新娘！ 需求一：抽出新郎 (BrideGroom) 與新娘 (Bride) 類別 新郎類別 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpnamespace App\\VisitorPattern\\Wedding;class BrideGroom&#123; /** * @param string $weddingType */ public function getClothes($weddingType) &#123; switch ($weddingType) &#123; case 'Chinese': echo \"新郎：中式囍袍\\n\"; break; case 'Japanese': echo \"新郎：繡有家紋的和服\\n\"; break; &#125; &#125; /** * @param string $weddingType */ public function getShoes($weddingType) &#123; switch ($weddingType) &#123; case 'Chinese': echo \"新郎：黑色秀禾鞋\\n\"; break; case 'Japanese': echo \"新郎：雪駄\\n\"; break; &#125; &#125;&#125; 新娘類別 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpnamespace App\\VisitorPattern\\Wedding;class Bride&#123; /** * @param string $weddingType */ public function getClothes($weddingType) &#123; switch ($weddingType) &#123; case 'Chinese': echo \"新娘：龍鳳褂\\n\"; break; case 'Japanese': echo \"新娘：純潔的白無垢\\n\"; break; &#125; &#125; /** * @param string $weddingType */ public function getShoes($weddingType) &#123; switch ($weddingType) &#123; case 'Chinese': echo \"新娘：紅色秀禾鞋\\n\"; break; case 'Japanese': echo \"新娘：草履\\n\"; break; &#125; &#125;&#125; 最後改寫既有程式碼 123456789101112131415161718192021&lt;?phpnamespace App\\VisitorPattern\\Wedding;class Program&#123; /** * @param string $weddingType */ public function getWedding($weddingType) &#123; $brideGroom = new BrideGroom(); $bride = new Bride(); $brideGroom-&gt;getClothes($weddingType); $brideGroom-&gt;getShoes($weddingType); $bride-&gt;getClothes($weddingType); $bride-&gt;getShoes($weddingType); &#125;&#125; 正當我們得意洋洋之時，老闆說了一個令人震驚的需求。 Boss：「隨著版圖擴張，我們之後要支援印度、烏克蘭等各國的婚禮服裝。」 經過觀察我們可以發現，不過是哪一國的婚禮，主角皆是新郎與新娘，且都需要取得服裝與鞋子。 其資料結構是穩定的。變動的是服裝與鞋子的操作。 讓我們用訪問者模式改寫它！ 需求二：配合版圖的擴張，實作訪問者模式 定義婚禮角色介面 123456789101112131415161718&lt;?phpnamespace App\\VisitorPattern\\Wedding\\Contracts;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingType;interface WeddingRole&#123; /** * @param WeddingType $weddingType */ public function getClothes($weddingType); /** * @param WeddingType $weddingType */ public function getShoes($weddingType);&#125; 定義婚禮類型介面 12345678910111213141516&lt;?phpnamespace App\\VisitorPattern\\Wedding\\Contracts;interface WeddingType&#123; /** * @param WeddingRole $role */ public function getClothes($role); /** * @param WeddingRole $role */ public function getShoes($role);&#125; WeddingRole是原本的**元素類別 (Element)**。 WeddingType則是原本元素類別中的操作，會成為我們的**訪問者類別 (Visitor)。根據傳入的元素類別 (Element)**，而有對應的行為。 修改原本的新郎類別 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\VisitorPattern\\Wedding;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingRole;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingType;class BrideGroom implements WeddingRole&#123; /** * @var string */ public $name = 'BrideGroom'; /** * @param WeddingType $weddingType */ public function getClothes($weddingType) &#123; $weddingType-&gt;getClothes($this); &#125; /** * @param WeddingType $weddingType */ public function getShoes($weddingType) &#123; $weddingType-&gt;getShoes($this); &#125;&#125; 修改原本的新娘類別 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\VisitorPattern\\Wedding;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingRole;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingType;class Bride implements WeddingRole&#123; /** * @var string */ public $name = 'Bride'; /** * @param WeddingType $weddingType */ public function getClothes($weddingType) &#123; $weddingType-&gt;getClothes($this); &#125; /** * @param WeddingType $weddingType */ public function getShoes($weddingType) &#123; $weddingType-&gt;getShoes($this); &#125;&#125; BrideGroom與Bride會由客戶端將WeddingType傳入（第一次分派）之後再將自己傳給WeddingType （第二次分派）。 實作中式婚禮 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace App\\VisitorPattern\\Wedding\\Type;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingType;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingRole;class ChineseWedding implements WeddingType&#123; /** * @param WeddingRole $role */ public function getClothes($role) &#123; $roleName = $role-&gt;name; switch ($roleName) &#123; case 'BrideGroom': echo \"新郎：中式囍袍\\n\"; break; case 'Bride': echo \"新娘：龍鳳褂\\n\"; break; &#125; &#125; /** * @param WeddingRole $role */ public function getShoes($role) &#123; $roleName = $role-&gt;name; switch ($roleName) &#123; case 'BrideGroom': echo \"新郎：黑色秀禾鞋\\n\"; break; case 'Bride': echo \"新娘：紅色秀禾鞋\\n\"; break; &#125; &#125;&#125; 實作日式婚禮 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace App\\VisitorPattern\\Wedding\\Type;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingType;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingRole;class JapaneseWedding implements WeddingType&#123; /** * @param WeddingRole $role */ public function getClothes($role) &#123; $roleName = $role-&gt;name; switch ($roleName) &#123; case 'BrideGroom': echo \"新郎：繡有家紋的和服\\n\"; break; case 'Bride': echo \"新娘：純潔的白無垢\\n\"; break; &#125; &#125; /** * @param WeddingRole $role */ public function getShoes($role) &#123; $roleName = $role-&gt;name; switch ($roleName) &#123; case 'BrideGroom': echo \"新郎：雪駄\\n\"; break; case 'Bride': echo \"新娘：草履\\n\"; break; &#125; &#125;&#125; 各國婚禮會根據傳入婚禮角色得不同，而有不同的行為。 實作婚禮類型工廠，方便客戶端呼叫 12345678910111213141516171819202122&lt;?phpnamespace App\\VisitorPattern\\Wedding;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingType;use ReflectionClass;class WeddingTypeFactory&#123; /** * @param string $weddingType * @return WeddingType */ public function create($weddingType) &#123; $namespace = 'App\\VisitorPattern\\Wedding\\Type'; $className = $weddingType . 'Wedding'; $reflector = new ReflectionClass($namespace . '\\\\' . $className); return $reflector-&gt;newInstance(); &#125;&#125; 實作物件結構類別，用來放入元素，便於我們實現遍歷。方便客戶端的呼叫。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace App\\VisitorPattern\\Wedding;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingRole;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingType;class Composite&#123; /** * @var WeddingRole[] */ protected $children = []; /** * @param WeddingRole $role * @return void */ public function add(WeddingRole $role) &#123; $this-&gt;children[$role-&gt;name] = $role; &#125; /** * @param WeddingRole $component * @return void */ public function remove(WeddingRole $role) &#123; unset($this-&gt;children[$role-&gt;name]); &#125; /** * @param WeddingType $weddingType * @return void */ public function display(WeddingType $weddingType) &#123; foreach ($this-&gt;children as $child) &#123; $child-&gt;getClothes($weddingType); $child-&gt;getShoes($weddingType); &#125; &#125;&#125; 最後修改既有程式碼 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace App\\VisitorPattern\\Wedding;use App\\VisitorPattern\\Wedding\\Contracts\\WeddingType;use App\\VisitorPattern\\Wedding\\WeddingTypeFactory;use App\\VisitorPattern\\Wedding\\Composite;use App\\VisitorPattern\\Wedding\\BrideGroom;use App\\VisitorPattern\\Wedding\\Bride;class Program&#123; /** * @var WeddingTypeFactory */ protected $weddingTypeFactory; public function __construct() &#123; $this-&gt;weddingTypeFactory = new WeddingTypeFactory(); &#125; /** * @param string $weddingType */ public function getWedding($weddingType) &#123; $weddingType = $this-&gt;createWeddingType($weddingType); $composite = new Composite(); $brideGroom = new BrideGroom(); $bride = new Bride(); $composite-&gt;add($brideGroom); $composite-&gt;add($bride); $composite-&gt;display($weddingType); &#125; /** * @param string $weddingType * @return WeddingType */ private function createWeddingType($weddingType) &#123; return $this-&gt;weddingTypeFactory-&gt;create($weddingType); &#125;&#125; \b[單一職責原則]我們將婚禮角色（資料結構）與婚禮類型（操作）視作兩種不同的職責。 \b[開放封閉原則]新增/修改婚禮類型時，不會修改到所有的程式碼。 \b[介面隔離原則]婚禮角色介面：會根據客戶端傳入的婚禮類型，再將自己傳入後，完成行為。婚禮類型介面：會根據傳入的婚禮角色，完成行為。 \b[依賴反轉原則]依賴於抽象的婚禮角色介面與婚禮類型介面。 ʕ •ᴥ•ʔ：揉合許多模式的範例。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"訪問者模式","slug":"Visitor-Pattern","date":"2020-12-27T08:36:05.000Z","updated":"2020-12-27T09:17:01.678Z","comments":true,"path":"2020/12/27/Visitor-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/12/27/Visitor-Pattern/","excerpt":"Visitor Pattern","text":"Visitor Pattern允許在不改變組合內各元素的情況下，增加各元素的新操作。。Example: 各國婚禮 訪問者模式會將類別分為兩類：分別是**訪問者類別 (Visitor)與元素類別 (Element)**。 讓原本屬於元素的行為，變成**訪問者類別 (Visitor)。根據傳入元素的不同，會有對應的行為，緊耦合於元素類別 (Element)**。 優點：將操作從元素類別抽離，使其能獨立變化。容易新增/修改訪問者類別。 缺點：難以增加新的元素。破壞了原本元素的封裝。會使程式碼複雜度提高。 與其他模式的比較：[組合模式]：訪問者模式可能會使用到組合模式的技巧。 [迭代器模式]：訪問者模式可能會使用到迭代器模式的技巧。 ʕ •ᴥ•ʔ：訪問者模式改變了原本的主從關係。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：打招呼（中介者模式）","slug":"Class-Diagram-Say-Hello-Mediator-Pattern","date":"2020-12-20T08:47:01.000Z","updated":"2020-12-20T12:44:17.861Z","comments":true,"path":"2020/12/20/Class-Diagram-Say-Hello-Mediator-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/12/20/Class-Diagram-Say-Hello-Mediator-Pattern/","excerpt":"Class-Diagram-Say-Hello-Mediator-Pattern","text":"Example: 打招呼 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：打招呼（中介者模式）","slug":"Example-Say-Hello-Mediator-Pattern","date":"2020-12-20T08:45:20.000Z","updated":"2020-12-26T08:56:57.642Z","comments":true,"path":"2020/12/20/Example-Say-Hello-Mediator-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/12/20/Example-Say-Hello-Mediator-Pattern/","excerpt":"Example-Say-Hello-Mediator-Pattern","text":"Pattern: 中介者模式 Class Diagram: 打招呼 \b情境：以下是人腦的運作程式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpnamespace App\\MediatorPattern\\SayHello;class Program&#123; /** * @param string $item * @return string */ public function see($item) &#123; switch ($item) &#123; case '認識的人': return $this-&gt;sayHello(); break; case '熟識的人': return $this-&gt;waveHand(); break; &#125; &#125; /** * @param string $item * @return string */ public function hear($item) &#123; switch ($item) &#123; case '喜歡的人': return $this-&gt;blush(); break; case '討厭的人': return $this-&gt;pretendToLookBusy(); break; &#125; &#125; private function sayHello() &#123; return '[嘴巴]發出[你好]的聲音'; &#125; private function waveHand() &#123; return '[手]做出[揮手]的動作'; &#125; private function blush() &#123; return '[臉]開始[發紅]'; &#125; private function pretendToLookBusy() &#123; return '[手]做出[裝忙]的動作'; &#125;&#125; 隨著行為日趨複雜，我們可能會有更多的動作。這些動作會聯繫著不同的器官。 因為強耦合，無論是器官的增加或是行為改變，都會大大地影響既有程式碼。 讓我們用中介者模式改造它！ 需求一：定義中介者介面 (Mediator)與合作者介面 (Colleague) 使用中樞神經系統作為中介者介面 (Mediator) 12345678910111213&lt;?phpnamespace App\\MediatorPattern\\SayHello\\Contracts;interface CentralNervousSystem&#123; /** * @param string $organName * @param string $message * @return string */ public function sendMessage($organName, $message);&#125; 使用器官作為合作者介面 (Colleague) 123456789101112&lt;?phpnamespace App\\MediatorPattern\\SayHello\\Contracts;interface Executable&#123; /** * @param string $message * @return string */ public function execute($message);&#125; 需求二：定義實體中介者，來改變合作者間的依賴關係 實作大腦（中介者） 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\\MediatorPattern\\SayHello;use App\\MediatorPattern\\SayHello\\Contracts\\CentralNervousSystem;use App\\MediatorPattern\\SayHello\\Abstracts\\Organ;class Brain implements CentralNervousSystem&#123; /** * @var Organ[] */ protected $organs = []; /** * @param string $organName * @param string $message * @return string */ public function sendMessage($organName, $message) &#123; $organ = $this-&gt;organs[$organName]; return $organ-&gt;execute($message); &#125; public function setOrgan(Organ $organ) &#123; $organName = $organ-&gt;getName(); $this-&gt;organs[$organName] = $organ; &#125;&#125; 抽象器官（合作者） 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\MediatorPattern\\SayHello\\Abstracts;use App\\MediatorPattern\\SayHello\\Contracts\\Executable;use App\\MediatorPattern\\SayHello\\Brain;abstract class Organ implements Executable&#123; /** * @var string */ protected $name = 'Unknown'; /** * @var Brain */ protected $brain; public function __construct(Brain $brain) &#123; $this-&gt;brain = $brain; &#125; public function getName() &#123; return $this-&gt;name; &#125;&#125; 實作眼睛 (合作者) 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\\MediatorPattern\\SayHello;use App\\MediatorPattern\\SayHello\\Abstracts\\Organ;class Eye extends Organ&#123; /** * @var string */ protected $name = '眼睛'; /** * @param string $message * @return string */ public function execute($message) &#123; switch ($message) &#123; case '認識的人': return $this-&gt;brain-&gt;sendMessage('嘴巴', '你好'); break; case '熟識的人': return $this-&gt;brain-&gt;sendMessage('手', '揮手'); break; &#125; &#125;&#125; 實作耳朵 (合作者) 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\MediatorPattern\\SayHello;use App\\MediatorPattern\\SayHello\\Abstracts\\Organ;class Ear extends Organ&#123; /** * @var string */ protected $name = '耳朵'; /** * @param string $message * @return string */ public function execute($message) &#123; switch ($message) &#123; case '喜歡的人': return $this-&gt;brain-&gt;sendMessage('臉', '發紅'); break; case '討厭的人': return $this-&gt;brain-&gt;sendMessage('手', '裝忙'); break; &#125; &#125;&#125; 實作手 (合作者) 12345678910111213141516171819&lt;?phpnamespace App\\MediatorPattern\\SayHello;use App\\MediatorPattern\\SayHello\\Abstracts\\Organ;class Hand extends Organ&#123; protected $name = '手'; /** * @param string $message * @return string */ public function execute($message) &#123; return \"[手]做出[$message]的動作\"; &#125;&#125; 實作嘴巴 (合作者) 12345678910111213141516171819202122&lt;?phpnamespace App\\MediatorPattern\\SayHello;use App\\MediatorPattern\\SayHello\\Abstracts\\Organ;class Mouth extends Organ&#123; /** * @var string */ protected $name = '嘴巴'; /** * @param string $message * @return string */ public function execute($message) &#123; return \"[嘴巴]發出[$message]的聲音\"; &#125;&#125; 實作臉 (合作者) 12345678910111213141516171819202122&lt;?phpnamespace App\\MediatorPattern\\SayHello;use App\\MediatorPattern\\SayHello\\Abstracts\\Organ;class Face extends Organ&#123; /** * @var string */ protected $name = '臉'; /** * @param string $message * @return string */ public function execute($message) &#123; return \"[臉]開始[$message]\"; &#125;&#125; 以這個範例來說，中介者是大腦，合作者則是各個器官。 當A器官要呼叫B器官，執行某些動作時，會透過大腦，使得A器官不必知道真正的B器官是誰（鬆耦合）。 需求三：改寫既有程式碼 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?phpnamespace App\\MediatorPattern\\SayHello;use App\\MediatorPattern\\SayHello\\Brain;use App\\MediatorPattern\\SayHello\\Eye;use App\\MediatorPattern\\SayHello\\Mouth;use App\\MediatorPattern\\SayHello\\Hand;use App\\MediatorPattern\\SayHello\\Ear;use App\\MediatorPattern\\SayHello\\Face;class Program&#123; /** * @var Brain */ protected $brain; /** * @var Eye */ protected $eye; /** * @var Mouth */ protected $mouth; /** * @var Hand */ protected $hand; /** * @var Ear */ protected $ear; /** * @var Face */ protected $face; public function __construct() &#123; $this-&gt;brain = $this-&gt;resolveBrainAndOrgans(); &#125; /** * @param string $item * @return string */ public function see($item) &#123; return $this-&gt;eye-&gt;execute($item); &#125; /** * @param string $item * @return string */ public function hear($item) &#123; return $this-&gt;ear-&gt;execute($item); &#125; private function resolveBrainAndOrgans() &#123; $this-&gt;brain = new Brain(); $this-&gt;resolveOrgans(); $this-&gt;brain-&gt;setOrgan($this-&gt;eye); $this-&gt;brain-&gt;setOrgan($this-&gt;mouth); $this-&gt;brain-&gt;setOrgan($this-&gt;hand); $this-&gt;brain-&gt;setOrgan($this-&gt;ear); $this-&gt;brain-&gt;setOrgan($this-&gt;face); &#125; private function resolveOrgans() &#123; $this-&gt;eye = new Eye($this-&gt;brain); $this-&gt;mouth = new Mouth($this-&gt;brain); $this-&gt;hand = new Hand($this-&gt;brain); $this-&gt;ear = new Ear($this-&gt;brain); $this-&gt;face = new Face($this-&gt;brain); &#125;&#125; \b[單一職責原則]我們將器官的功能與器官間的關係視作兩種不同的職責。 藉由大腦（中介者）負責聯絡各個器官（合作者）執行對應的行為。 \b[開放封閉原則]無論是新增/修改器官，或者新增/修改器官間的關係，我們都不會改動到所有程式碼。 \b[介面隔離原則]中介者介面：負責傳送器官間的訊息。合作者介面：負責執行該器官的功能。 \b[依賴反轉原則]大腦依賴於合作者介面。器官負責實作合作者介面。 ʕ •ᴥ•ʔ：早上剛睡醒時，想到的範例。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"中介者模式","slug":"Mediator-Pattern","date":"2020-12-20T08:44:51.000Z","updated":"2020-12-26T08:39:38.723Z","comments":true,"path":"2020/12/20/Mediator-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/12/20/Mediator-Pattern/","excerpt":"Mediator-Pattern","text":"Mediator Pattern集中相關對象的之間複雜的溝通與控制方式。Example: 打招呼 中介者模式會將類別分為兩類：分別是**中介者類別 (Mediator)與合作者類別 (Colleague)**。 優點：容易新增/修改合作者。容易新增/修改合作者之間的關係。合作者間不必互相參考，使其達到鬆耦合。 缺點：中介者會成為**神一般的存在(God Object)**。 與其他模式的比較：[狀態模式]：以關係圖來說，兩個模式皆透過相互參照的方式，消除同分類類別下的強耦合。 起初我會以為中介者模式會類似於Laravel的Container，但兩者目的有很大的不同。 Container主要目的是單例模式與註冊表的實現。而中介者關注在解除合作者之間的耦合關係。 ʕ •ᴥ•ʔ：World Peace!","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：新產品開發（職責鏈模式）","slug":"Class-Diagram-Software-Chain-Of-Responsibility-Pattern","date":"2020-12-11T14:17:52.000Z","updated":"2020-12-12T15:04:40.029Z","comments":true,"path":"2020/12/11/Class-Diagram-Software-Chain-Of-Responsibility-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/12/11/Class-Diagram-Software-Chain-Of-Responsibility-Pattern/","excerpt":"Class Diagram:Software (Chain Of Responsibility Pattern)","text":"Example: 新產品開發 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：新產品開發（職責鏈模式）","slug":"Example-Software-Chain-Of-Responsibility-Pattern","date":"2020-12-11T14:17:02.000Z","updated":"2020-12-12T14:57:13.533Z","comments":true,"path":"2020/12/11/Example-Software-Chain-Of-Responsibility-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/12/11/Example-Software-Chain-Of-Responsibility-Pattern/","excerpt":"Example:Software (Chain Of Responsibility Pattern)","text":"Pattern: 職責鏈模式 Class Diagram: 新產品開發 \b情境：公司開發了一個新產品，客戶端有許多不同的請求 客戶端的請求類別 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpnamespace App\\ChainOfResponsibilityPattern\\Software;class Request&#123; /** * @var string */ protected $type; /** * @var string */ protected $content; /** * @param string $type * @param string $content */ public function __construct(string $type, string $content) &#123; $this-&gt;type = $type; $this-&gt;content = $content; &#125; /** * @return string */ public function getType() &#123; return $this-&gt;type; &#125; /** * @return string */ public function getContent() &#123; return $this-&gt;content; &#125;&#125; 原本處理客戶端請求的方式 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace App\\ChainOfResponsibilityPattern\\Software;use Tests\\Unit\\ChainOfResponsibilityPattern\\Software\\Request;class Program&#123; /** * @param Request $request * @return string */ public function handle(Request $request) &#123; $type = $request-&gt;getType(); $content = $request-&gt;getContent(); switch ($type) &#123; case 'bug': // $request = new Request('bug', 'no connection'); return \"Support已開始處理[$type\b:$content]的問題。\"; break; case 'feature': // $request = new Request('feature', 'add filter'); return \"PM已開始處理[$type:$content]的問題。\"; break; default: // $request = new Request('cooperative business', 'become Google partner'); return \"Boss已開始處理[$type:$content]的問題。\"; break; &#125; &#125;&#125; 根據請求類型的不同，我們會交由不同的角色來處理問題。 但這些請求，可以透過區分請求類別的方式，統一先交由Support處理，若Support無法處理，再轉給下個負責人。 以這樣的想法，讓我們用職責鏈模式改造它。 首先是抽象的處理器類別，當該處理器無法處理時，會轉給下一個處理器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpnamespace App\\ChainOfResponsibilityPattern\\Software\\Abstracts;use App\\ChainOfResponsibilityPattern\\Software\\Request;abstract class Handler&#123; /** * @var string */ protected $role; /** * @var array */ protected $canHandleType = []; /** * @var string */ protected $requestType; /** * @var string */ protected $requestContent; /** * @var Handler */ protected $nextHandler; /** * @param Request $request * @return string */ public function handle(Request $request): string &#123; $this-&gt;requestType = $request-&gt;getType(); $this-&gt;requestContent = $request-&gt;getContent(); if ($this-&gt;canHandle()) &#123; $role = $this-&gt;role; $result = \"$role can solve [$this-&gt;requestType:$this-&gt;requestContent] issue.\"; return $result; &#125; return $this-&gt;nextHandler-&gt;handle($request); &#125; /** * @param Handler $handler */ public function setNextHandler(Handler $handler) &#123; $this-&gt;nextHandler = $handler; &#125; /** * @return boolean */ protected function canHandle() &#123; return in_array($this-&gt;requestType, $this-&gt;canHandleType); &#125;&#125; 由canHandle()方法來知道，該處理器能不能處理。由setNextHandler()方法，來決定下一個處理器。 Support處理器 123456789101112131415161718&lt;?phpnamespace App\\ChainOfResponsibilityPattern\\Software;use App\\ChainOfResponsibilityPattern\\Software\\Abstracts\\Handler;class Support extends Handler&#123; /** * @var string */ protected $role = 'Support'; /** * @var array */ protected $canHandleType = ['bug'];&#125; PM處理器 123456789101112131415161718&lt;?phpnamespace App\\ChainOfResponsibilityPattern\\Software;use App\\ChainOfResponsibilityPattern\\Software\\Abstracts\\Handler;class ProjectManager extends Handler&#123; /** * @var string */ protected $role = 'PM'; /** * @var array */ protected $canHandleType = ['bug', 'feature'];&#125; Boss處理器 123456789101112131415161718192021&lt;?phpnamespace App\\ChainOfResponsibilityPattern\\Software;use App\\ChainOfResponsibilityPattern\\Software\\Abstracts\\Handler;class Boss extends Handler&#123; /** * @var string */ protected $role = 'Boss'; /** * @return boolean */ protected function canHandle() &#123; return true; &#125;&#125; 最後修改原本的程式碼 123456789101112131415161718192021&lt;?phpnamespace App\\ChainOfResponsibilityPattern\\Software;use App\\ChainOfResponsibilityPattern\\Software\\Request;use App\\ChainOfResponsibilityPattern\\Software\\Support;class Program&#123; public function handle(Request $request) &#123; $support = new Support(); $projectManager = new ProjectManager(); $boss = new Boss(); $support-&gt;setNextHandler($projectManager); $projectManager-&gt;setNextHandler($boss); return $support-&gt;handle($request); &#125;&#125; 這邊可以留意，若有未定義類型的請求，最終都會交由Boss處理器來捕捉。 \b[單一職責原則]我們把處理器與處理器的順序視作兩種不同的職責。 \b[開放封閉原則]無論是新增/修改處理器的邏輯，或者修改處理器的順序，皆不會改動到所有程式碼。 \b[依賴反轉原則]抽象的處理器類別依賴於自身（組合模式）。實體的處理器類別則實現它。 ʕ •ᴥ•ʔ：一個很生活化的設計模式。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"職責鏈模式","slug":"Chain-Of-Responsibility-Pattern","date":"2020-12-11T14:16:08.000Z","updated":"2020-12-12T14:34:34.961Z","comments":true,"path":"2020/12/11/Chain-Of-Responsibility-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/12/11/Chain-Of-Responsibility-Pattern/","excerpt":"Chain Of Responsibility Pattern","text":"Chain Of Responsibility Pattern使多個物件都有機會處理請求，從而避免請求的發送者和接受者間的耦合關係。請求會沿著這條鏈傳遞，直到有一個物件處理它。Example: 新產品開發 職責鏈模式會將類別分為兩類：分別是**請求類別 (Request)與處理器類別 (Handler)**。 優點：容易調整職責鏈中處理器的順序。容易新增/修改職責鏈中的處理器。 缺點：需注意是否有請求到鏈的末端仍未被處理。 與其他模式的比較：[裝飾者模式]：裝飾者模式中，每個裝飾者類別皆會裝飾被裝飾者類別。而職責鏈模式中的請求，只會交由一個處理器負責處理。 [組合模式]：職責鏈模式中的處理器類別，會實現相同的介面，最後形成類似**枝節點類別 (Composite)與葉節點類別 (Leaf)**的結構。 ʕ •ᴥ•ʔ：透過類似命令模式的職責切分，將處理器的職責與鏈的職責解耦，使其易於新增/修改。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：十二生肖（橋接模式）","slug":"Class-Diagram-Zodiac-Bridge-Pattern","date":"2020-11-22T15:28:25.000Z","updated":"2020-11-22T16:44:24.651Z","comments":true,"path":"2020/11/22/Class-Diagram-Zodiac-Bridge-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/11/22/Class-Diagram-Zodiac-Bridge-Pattern/","excerpt":"Class Diagram:Zodiac (Bridge Pattern)","text":"Example: 十二生肖 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：十二生肖","slug":"Example-Zodiac-Bridge-Pattern","date":"2020-11-21T10:50:37.000Z","updated":"2020-11-22T16:44:36.755Z","comments":true,"path":"2020/11/21/Example-Zodiac-Bridge-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/11/21/Example-Zodiac-Bridge-Pattern/","excerpt":"Example:Zodiac (Bridge Pattern)","text":"Pattern: 橋接模式 Class Diagram: 十二生肖 \b情境：玉皇大帝要舉辦渡河比賽，動物選手各顯神通。 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\BridgePattern\\Zodiac;class Program&#123; /** * @param string $animal */ public function crossRiver($animal) &#123; switch ($animal) &#123; case 'rat': echo '悠哉地站啊站'; break; case 'ox': echo '努力地游啊游'; break; case 'dragon': echo '壯麗地飛啊飛'; break; case 'snake': echo '迅速地滑啊滑'; break; &#125; &#125;&#125; 故事中，老鼠與貓站在水牛的背上。 水牛勤奮地游，龍翱翔於天際，蛇則獨樹一幟地滑行在水面⋯⋯ 但今天這都不是重點。 假如原有的動物選手要改變渡河方式？（比如貓貓決定自己游泳）假如要新增新的動物選手？（比如老虎也要參賽） 渡河方式與動物選手是兩種不同層級的職責。讓我們用橋接模式改寫它。 需求一：渡河方式 首先定義渡河方式的介面 12345678&lt;?phpnamespace App\\BridgePattern\\Zodiac\\Contracts;interface CrossRiverBehavior&#123; public function crossRiver();&#125; 渡河方式：站在水牛背上 12345678910111213&lt;?phpnamespace App\\BridgePattern\\Zodiac\\CrossRiverBehaviors;use App\\BridgePattern\\Zodiac\\Contracts\\CrossRiverBehavior;class RideAtopTheOx implements CrossRiverBehavior&#123; public function crossRiver() &#123; echo '悠哉地站啊站'; &#125;&#125; 渡河方式：日常游泳 12345678910111213&lt;?phpnamespace App\\BridgePattern\\Zodiac\\CrossRiverBehaviors;use App\\BridgePattern\\Zodiac\\Contracts\\CrossRiverBehavior;class Swim implements CrossRiverBehavior&#123; public function crossRiver() &#123; echo '努力地游啊游'; &#125;&#125; 渡河方式：無翅飛行 12345678910111213&lt;?phpnamespace App\\BridgePattern\\Zodiac\\CrossRiverBehaviors;use App\\BridgePattern\\Zodiac\\Contracts\\CrossRiverBehavior;class FlyWithNoWings implements CrossRiverBehavior&#123; public function crossRiver() &#123; echo '壯麗地飛啊飛'; &#125;&#125; 渡河方式：滑行 12345678910111213&lt;?phpnamespace App\\BridgePattern\\Zodiac\\CrossRiverBehaviors;use App\\BridgePattern\\Zodiac\\Contracts\\CrossRiverBehavior;class Slither implements CrossRiverBehavior&#123; public function crossRiver() &#123; echo '迅速地滑啊滑'; &#125;&#125; 需求二：動物選手 首先定義動物選手的介面 123456789101112131415161718&lt;?phpnamespace App\\BridgePattern\\Zodiac\\Abstracts;use App\\BridgePattern\\Zodiac\\Contracts\\CrossRiverBehavior;abstract class Contestant&#123; /** * @var CrossRiverBehavior */ protected $crossRiverBehavior; public function crossRiver() &#123; $this-&gt;crossRiverBehavior-&gt;crossRiver(); &#125;&#125; 此處的crossRiver()並沒有具體行為，而是交由渡河方式來實作！ 動物選手：老鼠 12345678910111213141516171819&lt;?phpnamespace App\\BridgePattern\\Zodiac\\Contestants;use App\\BridgePattern\\Zodiac\\CrossRiverBehaviors\\RideAtopTheOx;use App\\BridgePattern\\Zodiac\\Abstracts\\Contestant;class Rat extends Contestant&#123; /** * @var RideAtopTheOx */ protected $crossRiverBehavior; public function __construct() &#123; $this-&gt;crossRiverBehavior = new RideAtopTheOx(); &#125;&#125; 動物選手：水牛 123456789101112131415161718192021222324&lt;?phpnamespace App\\BridgePattern\\Zodiac\\Contestants;use App\\BridgePattern\\Zodiac\\CrossRiverBehaviors\\Swim;use App\\BridgePattern\\Zodiac\\Abstracts\\Contestant;class Ox extends Contestant&#123; /** * @var Swim */ protected $crossRiverBehavior; public function __construct() &#123; $this-&gt;crossRiverBehavior = new Swim(); &#125; public function crossRiver() &#123; $this-&gt;crossRiverBehavior-&gt;crossRiver(); &#125;&#125; 動物選手：龍 123456789101112131415161718192021222324&lt;?phpnamespace App\\BridgePattern\\Zodiac\\Contestants;use App\\BridgePattern\\Zodiac\\CrossRiverBehaviors\\FlyWithNoWings;use App\\BridgePattern\\Zodiac\\Abstracts\\Contestant;class Dragon extends Contestant&#123; /** * @var FlyWithNoWings */ protected $crossRiverBehavior; public function __construct() &#123; $this-&gt;crossRiverBehavior = new FlyWithNoWings(); &#125; public function crossRiver() &#123; $this-&gt;crossRiverBehavior-&gt;crossRiver(); &#125;&#125; 動物選手：蛇 12345678910111213141516171819&lt;?phpnamespace App\\BridgePattern\\Zodiac\\Contestants;use App\\BridgePattern\\Zodiac\\CrossRiverBehaviors\\Slither;use App\\BridgePattern\\Zodiac\\Abstracts\\Contestant;class Snake extends Contestant&#123; /** * @var Slither */ protected $crossRiverBehavior; public function __construct() &#123; $this-&gt;crossRiverBehavior = new Slither(); &#125;&#125; 最後修改原本的程式碼 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\\BridgePattern\\Zodiac;use ReflectionClass;use App\\BridgePattern\\Zodiac\\Contracts\\Contestant;class Program&#123; /** * @param string $animalName */ public function crossRiver($animalName) &#123; $contestant = $this-&gt;getContestant($animalName); $contestant-&gt;crossRiver(); &#125; /** * @param string $animalName * @return Contestant */ private function getContestant($animalName) &#123; $namespace = 'App\\BridgePattern\\Zodiac\\Contestants'; $className = ucfirst($animalName); $reflector = new ReflectionClass($namespace . '\\\\' . $className); return $reflector-&gt;newInstance(); &#125;&#125; 運用反射 (Reflection) 機制，讓客戶端的程式碼不再修改。 \b[單一職責原則]我們把渡河方式與動物選手視作兩種不同的職責。 \b[開放封閉原則]無論新增動物選手或者修改渡河方式，皆不會改動到所有程式碼。 \b[介面隔離原則]區分了渡河方式介面與動物選手介面。 雖然兩者目前都只有**crossRiver()**方法，但實作的目的不同。日後也可能因需求調整介面，而發展出截然不同的形式。 \b[依賴反轉原則]客戶端的程式碼依賴於動物選手介面。動物選手介面依賴於渡河方式介面。再由各個實體動物選手與實體渡河方式進行實作。 ʕ •ᴥ•ʔ：希望這個範例有淺顯易懂。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"橋接模式","slug":"Bridge-Pattern","date":"2020-11-21T10:41:22.000Z","updated":"2020-12-17T16:25:47.576Z","comments":true,"path":"2020/11/21/Bridge-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/11/21/Bridge-Pattern/","excerpt":"Bridge Pattern","text":"Bridge Pattern將抽象部分與實現部分分離，使它們都可以獨立地變化。Example: 十二生肖 橋接模式會將類別分為兩類：分別是**抽象類別 (Abstraction)與實現類別 (Implementor)**。 抽象類別指的是高層級的抽象層。本身不具備具體邏輯。而實現類別會由低層級的實作層來負責。 舉例：抽象類別 -&gt; 實現類別通話介面 -&gt; 室內電話、行動電話登入介面 -&gt; Web、App 優點：透過分離抽象層與實作層，可根據需求在不同層級上，作相應的變化。 缺點：會使程式碼複雜度提高。 與其他模式的比較：[策略模式]：策略模式屬於**行為型 (behavioral)的設計模式，而橋接模式屬於結構型 (structural)**的設計模式。 這使著兩者在目的上，有著根本的不同。 策略模式可能會隨著運行，動態地調整策略。而橋接模式則會像是兩種不同的實作架構。 [狀態模式]：狀態模式屬於**行為型 (behavioral)**的設計模式。可能會在運行過程中改變內部狀態，進而改變具體行為。 舉例： 設計模式 使用情境 策略模式 擁有多家第三方金流，需在主要金流服務掛點時，採用備用金流機制。 狀態模式 行人號誌小綠人會隨著當前標誌不同，顯示不同的圖樣。 橋接模式 框架實作資料庫連線的介面，與其各自不同的具體實作。 ʕ •ᴥ•ʔ：以Laravel而言，設計模式到後來常常會混血，最終還是回歸到S.O.L.I.D的思考。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：生物分類學（組合模式）","slug":"Class-Diagram-Taxonomy-Composite-Pattern","date":"2020-11-15T15:23:02.000Z","updated":"2020-11-16T15:38:09.308Z","comments":true,"path":"2020/11/15/Class-Diagram-Taxonomy-Composite-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/11/15/Class-Diagram-Taxonomy-Composite-Pattern/","excerpt":"Class Diagram:Taxonomy (Composite Pattern)","text":"Example: 生物分類學 （註：此處DashHelper以abstract class表示trait） ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：生物分類學（組合模式）","slug":"Example-Taxonomy-Composite-Pattern","date":"2020-11-15T15:21:23.000Z","updated":"2020-12-16T14:17:28.739Z","comments":true,"path":"2020/11/15/Example-Taxonomy-Composite-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/11/15/Example-Taxonomy-Composite-Pattern/","excerpt":"Example:Taxonomy (Composite Pattern)","text":"Pattern: 組合模式 Class Diagram: 生物分類學 \b情境：原本的生物分類學（界門綱目科屬種） 123456789101112131415161718192021222324&lt;?phpnamespace App\\CompositePattern\\Taxonomy;class Program&#123; public function getTaxonomy() &#123; echo '動物界-- 脊索動物門---- 哺乳綱------ 雙門齒目-------- 無尾熊科---------- 無尾熊屬------------ 無尾熊------ 食肉目-------- 熊科---------- 大貓熊屬------------ 大貓熊'; &#125;&#125; （註：排版是因為測試時不能有空格，也間接說明了這是個脆弱測試） 我們利用「-」來做出層級的分類概念。 經由分類發現，無尾熊與大貓熊同屬動物界\b-脊索動物門-哺乳綱。 讓我們透過組合模式，將其改寫成樹形架構！ 需求一：運用組合模式 首先定義組合介面 (Component)，採取透明模式 (uniformity) 123456789101112&lt;?phpnamespace App\\CompositePattern\\Taxonomy\\Contracts;interface Component&#123; public function add(Component $component); public function remove(Component $component); public function displayClassifiaction(int $depth);&#125; 定義DashHelper （重構時發現枝節點與葉節點可共用的方法） 1234567891011121314151617181920&lt;?phpnamespace App\\CompositePattern\\Taxonomy\\Traits;trait DashHelper&#123; /** * @param integer $count * @return string */ public function getDashes(int $count) &#123; $dash = ''; for ($i = 0; $i &lt; $count; $i++) &#123; $dash = $dash . '-'; &#125; return $dash; &#125;&#125; DashHelper目的是做出不同層的分類。 定義枝節點類別 (Composite) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?phpnamespace App\\CompositePattern\\Taxonomy;use App\\CompositePattern\\Taxonomy\\Contracts\\Component;use App\\CompositePattern\\Taxonomy\\Traits\\DashHelper;class Composite implements Component&#123; use DashHelper; /** * @var string */ public $name; /** * @var Component[] */ protected $children = []; /** * @param string $name */ public function __construct(string $name) &#123; $this-&gt;name = $name; &#125; /** * @param Component $component * @return void */ public function add(Component $component) &#123; $this-&gt;children[$component-&gt;name] = $component; &#125; /** * @param Component $component * @return void */ public function remove(Component $component) &#123; unset($this-&gt;children[$component-&gt;name]); &#125; /** * @param integer $depth * @return void */ public function displayClassifiaction(int $depth) &#123; $this-&gt;displaySelfClassification($depth); $this-&gt;displayChildrenClassification($depth); &#125; /** * @param int $depth * @return void */ private function displaySelfClassification(int $depth) &#123; $dashes = $this-&gt;getDashes($depth); if (strlen($dashes) == 0) &#123; echo \"$this-&gt;name\\n\"; return; &#125; echo \"$dashes $this-&gt;name\\n\"; &#125; /** * @param integer $depth * @return void */ private function displayChildrenClassification(int $depth) &#123; foreach ($this-&gt;children as $child) &#123; $child-&gt;displayClassifiaction($depth + 2); &#125; &#125;&#125; 枝節點會先印出自己的分類名稱，接著加層數給子物件。 定義葉節點類別 (Leaf) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpnamespace App\\CompositePattern\\Taxonomy;use App\\CompositePattern\\Taxonomy\\Contracts\\Component;use App\\CompositePattern\\Taxonomy\\Traits\\DashHelper;use Exception;class Leaf implements Component&#123; use DashHelper; /** * @var string */ public $name; /** * @param string $name */ public function __construct(string $name) &#123; $this-&gt;name = $name; &#125; /** * @param Component $component * @throws Exception */ public function add(Component $component) &#123; throw new Exception('Cannot add to a leaf'); &#125; /** * @param Component $component * @throws Exception */ public function remove(Component $component) &#123; throw new Exception('Cannot remove from a leaf'); &#125; /** * @param integer $depth * @return void */ public function displayClassifiaction(int $depth) &#123; $dashes = $this-&gt;getDashes($depth); echo \"$dashes $this-&gt;name\\n\\n\"; &#125;&#125; 葉節點只會列出自己的分類名稱，而且不允許對子物件的操作。 最後修改客戶端的程式碼 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpnamespace App\\CompositePattern\\Taxonomy;class Program&#123; public function getTaxonomy() &#123; $animalia = new Composite('動物界'); $chordata = new Composite('脊索動物門'); $mammalia = new Composite('哺乳綱'); $animalia-&gt;add($chordata); $chordata-&gt;add($mammalia); // koala $diprotodontia = new Composite('雙門齒目'); $phascolarctidae = new Composite('無尾熊科'); $phascolarctos = new Composite('無尾熊屬'); $phascolarctosCinereus = new Leaf('無尾熊'); $diprotodontia-&gt;add($phascolarctidae); $phascolarctidae-&gt;add($phascolarctos); $phascolarctos-&gt;add($phascolarctosCinereus); $mammalia-&gt;add($diprotodontia); // panda $carnivora = new Composite('食肉目'); $ursidae = new Composite('熊科'); $ailuropoda = new Composite('大貓熊屬'); $ailuropodaMelanoleuca = new Leaf('大貓熊'); $carnivora-&gt;add($ursidae); $ursidae-&gt;add($ailuropoda); $ailuropoda-&gt;add($ailuropodaMelanoleuca); $mammalia-&gt;add($carnivora); $animalia-&gt;displayClassifiaction(0); &#125;&#125; （註：此處的變數命名參考學名） \b[單一職責原則]透過找出可以繼續遞迴的部分，分出枝節點與葉節點。 \b[開放封閉原則]可以於組合中新增/修改某節點，不去影響其他節點的行為。 \b[依賴反轉原則]客戶依賴於抽象的**組合介面 (Component)。枝節點與葉節點實現抽象的組合介面 (Component)**。 ʕ •ᴥ•ʔ：動物界-脊索動物門-哺乳綱-靈長目-人科-人屬-人。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"組合模式","slug":"Composite-Pattern","date":"2020-11-15T15:16:08.000Z","updated":"2020-11-18T14:38:06.783Z","comments":true,"path":"2020/11/15/Composite-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/11/15/Composite-Pattern/","excerpt":"Composite Pattern","text":"Composite Pattern允許將對象組合成樹形結構來表現整體/部分層次結構。組合能讓客戶以一致的方式處理個別對象以及對象組合。Example: 生物分類學 組合模式會將類別分為兩類：分別是**枝節點類別 (Composite)與葉節點類別 (Leaf)**。 其中葉節點類別沒有子節點。 根據**組合介面 (Component)**設計的不同，又可分出兩種類型。 透明方式 (uniformity)於介面宣告管理子物件的方法 (Add, Remove)，使得**枝節點類別 (Composite)與葉節點類別 (Leaf)沒有區別。缺點為葉節點類別 (Leaf)**本身不具備管理子物件的方法，實現它是沒有意義的。 安全方式 (type safety)不於介面宣告管理子物件的方法，而是在**枝節點類別 (Composite)**中宣告。缺點為客戶端調用時須增加對應的判斷。 優點：面對樹形架構時，能夠使用多態性與遞迴性的作法。 缺點：由於介面須同時滿足枝節點與葉節點，會使程式碼複雜度提高。 與其他模式的比較：[迭代器模式]：運用組合模式，可以與迭代器模式產生良好的協同作用。 [解譯器模式]：兩者有著類似下表的對應關係。 解譯器模式 組合模式 終端表達式 (Terminal Expression) 葉節點類別 (Leaf) 非終端表達式 (NonTerminal Expression) 枝節點類別 (Composite) [裝飾者模式]：裝飾者模式只有一個裝飾過後的物件。而組合模式有著許多個物件。 ʕ •ᴥ•ʔ：組合模式的目的就是實現樹形結構。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：摩斯電碼 （解譯器模式）","slug":"Class-Diagram-Morse-Code-Interpreter-Pattern","date":"2020-11-08T12:10:05.000Z","updated":"2020-11-08T13:24:52.579Z","comments":true,"path":"2020/11/08/Class-Diagram-Morse-Code-Interpreter-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/11/08/Class-Diagram-Morse-Code-Interpreter-Pattern/","excerpt":"Class Diagram:Morse Code (Interpreter Pattern)","text":"Example: 摩斯電碼 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：摩斯電碼 （解譯器模式）","slug":"Example-Morse-Code-Interpreter-Pattern","date":"2020-11-08T11:24:18.000Z","updated":"2020-12-15T15:05:01.813Z","comments":true,"path":"2020/11/08/Example-Morse-Code-Interpreter-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/11/08/Example-Morse-Code-Interpreter-Pattern/","excerpt":"Example:Morse Code (Interpreter Pattern)","text":"Pattern: 解譯器模式 Class Diagram: 摩斯電碼 \b情境：讓我們試著作一個摩斯電碼機，它會將一般句子轉成摩斯電碼的表示 首先是語境類別 (Context) 12345678910111213141516171819&lt;?phpnamespace App\\InterpreterPattern\\MorseCode;class Context&#123; /** * @var string */ public $text; /** * @param string $text */ public function __construct(string $text) &#123; $this-&gt;text = $text; &#125;&#125; 主要是承載要解譯的詞句，會隨著解譯進度，改變其內容。 接著是表達式類別 (Expression) 1234567891011121314151617181920212223&lt;?phpnamespace App\\InterpreterPattern\\MorseCode\\Contracts;use App\\InterpreterPattern\\MorseCode\\Context;interface Expression&#123; /** * 找出要解析的字串執行，並回傳剩餘字串 * * @param Context $context * @return Context */ public function interpret(Context $context): Context; /** * 解析字串後，印在控制台 * * @param string $message */ public function execute(string $message);&#125; 這邊說明一下，所謂的摩斯電碼，是利用滴答兩種不同長短訊號的排列組合，來表達每一個字母符號。 例如：A的表示為 (.-)。 而在此處的範例中，同個單字的字母會用空格 ( ) 分開，不同單字的字母則會用斜槓 (/) 分開。 例如：Good Morning的表示會是 (–. — — -.. / – — .-. -. .. -. –.)。 字母間不區分大小寫。 按照上述規則，我想區分出兩種表達式 (Expression)。 解譯字母符號的為**終端表達式 (Terminal Expression)，其他情況為非終端表達式 (NonTerminal Expression)**。 想法是使用非終端表達式時，表示還有字需要解譯。 實作非終端表達式 (NonTerminal Expression) 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace App\\InterpreterPattern\\MorseCode;use App\\InterpreterPattern\\MorseCode\\Contracts\\Expression;use App\\InterpreterPattern\\MorseCode\\Context;class NonTerminalExpression implements Expression&#123; public function interpret(Context $context): Context &#123; $head = ' '; $context-&gt;text = trim($context-&gt;text); $this-&gt;execute($head); return $context; &#125; /** * @param string $message */ public function execute(string $message) &#123; echo ' / '; &#125; /** * @param string $character * @return boolean */ public function isSpace($character) &#123; return $character == ' '; &#125;&#125; 此處interpret()方法會將目前解譯到的詞句，去除前後空白。execute()方法則會印出斜槓 (/)。 而isSpace()方法，會在待會的客戶端程式碼用到。 實作終端表達式 (Terminal Expression) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;?phpnamespace App\\InterpreterPattern\\MorseCode;use App\\InterpreterPattern\\MorseCode\\Contracts\\Expression;use App\\InterpreterPattern\\MorseCode\\Context;use App\\InterpreterPattern\\MorseCode\\Exceptions\\UndefinedTextException;class TerminalExpression implements Expression&#123; protected $mapping = [ 'a' =&gt; '.-', 'b' =&gt; '-...', 'c' =&gt; '-.-.', 'd' =&gt; '-..', 'e' =&gt; '.', 'f' =&gt; '..-.', 'g' =&gt; '--.', 'h' =&gt; '....', 'i' =&gt; '..', 'j' =&gt; '.---', 'k' =&gt; '-.-', 'l' =&gt; '.-..', 'm' =&gt; '--', 'n' =&gt; '-.', 'o' =&gt; '---', 'p' =&gt; '.--.', 'q' =&gt; '--.-', 'r' =&gt; '.-.', 's' =&gt; '...', 't' =&gt; '-', 'u' =&gt; '..-', 'v' =&gt; '...-', 'w' =&gt; '.--', 'x' =&gt; '-..-', 'y' =&gt; '-.--', 'z' =&gt; '--..', '0' =&gt; '-----', '1' =&gt; '.----', '2' =&gt; '..---', '3' =&gt; '...--', '4' =&gt; '....-', '5' =&gt; '.....', '6' =&gt; '-....', '7' =&gt; '--...', '8' =&gt; '---..', '9' =&gt; '----.', '.' =&gt; '.-.-.-', ',' =&gt; '--..--', '?' =&gt; '..--..', '/' =&gt; '-..-.', \"'\" =&gt; '.----.', '!' =&gt; '-.-.--', ]; public function interpret(Context $context): Context &#123; $firstSpacePos = strpos($context-&gt;text, ' '); if ($firstSpacePos) &#123; $head = substr($context-&gt;text, 0, $firstSpacePos); $context-&gt;text = substr($context-&gt;text, $firstSpacePos); &#125; else &#123; $head = $context-&gt;text; $context-&gt;text = ''; &#125; $this-&gt;execute($head); return $context; &#125; /** * @param string $message */ public function execute(string $message) &#123; $characters = str_split($message); $lastKey = array_key_last($characters); foreach ($characters as $key =&gt; $character) &#123; $this-&gt;encode($character); if ($key == $lastKey) &#123; break; &#125; $this-&gt;typeSpace(); &#125; &#125; /** * @param string $character */ private function encode(string $character) &#123; $character = strtolower($character); if (!array_key_exists($character, $this-&gt;mapping)) &#123; throw new UndefinedTextException(); &#125; echo $this-&gt;mapping[$character]; &#125; private function typeSpace() &#123; echo ' '; &#125;&#125; 此處interpret()方法會找出要解譯的單字，並截斷它。execute()方法則會逐步印出單字中的每一個字母符號，彼此間以空格隔開。 實作客戶端的程式碼 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace App\\InterpreterPattern\\MorseCode;use App\\InterpreterPattern\\MorseCode\\NonTerminalExpression;use App\\InterpreterPattern\\MorseCode\\TerminalExpression;use App\\InterpreterPattern\\MorseCode\\Context;class Program&#123; /** * @var TerminalExpression */ protected $terminalExpression; /** * @var NonTerminalExpression */ protected $nonTerminalExpression; public function __construct() &#123; $this-&gt;terminalExpression = new TerminalExpression(); $this-&gt;nonTerminalExpression = new NonTerminalExpression(); &#125; /** * @param string $text */ public function encode(string $text) &#123; try &#123; $context = new Context(trim($text)); while (strlen($context-&gt;text) &gt; 0) &#123; $firstCharacter = substr($context-&gt;text, 0, 1); if ($this-&gt;nonTerminalExpression-&gt;isSpace($firstCharacter)) &#123; $context = $this-&gt;nonTerminalExpression-&gt;interpret($context); continue; &#125; $context = $this-&gt;terminalExpression-&gt;interpret($context); &#125; &#125; catch (\\Throwable $th) &#123; throw $th; &#125; &#125;&#125; 最後讓我們來看客戶端程式碼怎麼跑吧！ 以Hello World為例： 首先會將Hello World轉成**語境類別 (Context)**。 終端表達式 (Terminal Expression) 會截取出Hello這個單字，印出它的摩斯電碼。 非終端表達式 (NonTerminal Expression) 則會去除空白，印出斜槓 (/)。 終端表達式 (Terminal Expression) 會截取出World這個單字，印出它的摩斯電碼。 客戶端程式碼判斷解譯完成，結束迴圈。 \b[單一職責原則]**語境類別 (Context)**：負責乘載要解譯的詞句。非終端表達式 (NonTerminal Expression)：負責連結解譯單字間的文法。**終端表達式 (Terminal Expression)**：負責解譯每一個字母符號。 \b[開放封閉原則]增加要轉譯的字母符號時，僅需修改終端表達式 (Terminal Expression)。 \b[依賴反轉原則]透過表達式 (Expression) 接口，確保各個表達式都有interpret()方法與execute()方法。 現實中幾乎沒有機會使用到的設計模式，範例想了很多天，希望這樣有傳達出這個模式的精神！ 另外這個範例還沒有完成decode()方法，也就是從摩斯電碼轉回一般句子。 之後有時間會試著實作看看。 ʕ •ᴥ•ʔ：目前心目中前三難的設計模式。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"解譯器模式","slug":"Interpreter-Pattern","date":"2020-11-04T09:53:00.000Z","updated":"2020-11-08T12:11:42.606Z","comments":true,"path":"2020/11/04/Interpreter-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/11/04/Interpreter-Pattern/","excerpt":"Interpreter Pattern","text":"Interpreter Pattern給定一個語言，定義它的語法表示與文法。利用不同的表達式來翻譯語言中的句子。Example: 摩斯電碼 解譯器模式會將類別分為兩類：分別是**語境類別 (Context)與表達式類別 (Expression)**。 其中語境類別為待翻譯的資料。透過客戶端依序呼叫不同的表達式類別來完成翻譯。 通常一種文法（規則）會對應一個表達式。 \b語言通常會是**領域特定語言 (Domain Specific Language)**，即專注於某個應用程式領域的計算機語言。 （例如：SQL, HTML, Regular Expressions） 優點：用來定義簡單語言的文法，使它們可以被翻譯。 缺點：程式碼複雜度提高。當文法變得複雜時，難以維護。 ʕ •ᴥ•ʔ：程式界的翻譯蒟蒻！","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：文字積木 （蠅量模式）","slug":"Class-Diagram-Blocks-Flyweight-Pattern","date":"2020-11-02T13:24:10.000Z","updated":"2020-11-02T14:18:03.110Z","comments":true,"path":"2020/11/02/Class-Diagram-Blocks-Flyweight-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/11/02/Class-Diagram-Blocks-Flyweight-Pattern/","excerpt":"Class Diagram:Blocks (Flyweight Pattern)","text":"Example: 文字積木 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：文字積木 （蠅量模式）","slug":"Example-Blocks-Flyweight-Pattern","date":"2020-11-01T16:14:55.000Z","updated":"2020-11-04T12:34:48.494Z","comments":true,"path":"2020/11/02/Example-Blocks-Flyweight-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/11/02/Example-Blocks-Flyweight-Pattern/","excerpt":"Example:Blocks (Flyweight Pattern)","text":"Pattern: 蠅量模式 Class Diagram: 文字積木 \b情境：這是公司生產的文字積木 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpnamespace App\\Flyweight\\Blocks;class ConcreteBlock&#123; /** * @var string */ protected $shape; /** * @var string */ public $word; /** * @param string $shape * @param string $word */ public function __construct(string $shape, string $word) &#123; $this-&gt;shape = $shape; $this-&gt;word = $word; &#125; /** * @return string */ public function getShape(): string &#123; return $this-&gt;shape; &#125; /** * @return string */ public function getWord(): string &#123; return $this-&gt;word; &#125;&#125; 客戶端的使用方式 12345678910111213141516171819202122namespace App\\Flyweight\\Blocks;&lt;?phpnamespace App\\Flyweight\\Blocks;use App\\Flyweight\\Blocks\\ConcreteBlock;class Program&#123; /** * @return array */ public function getBlocks(): array &#123; $firstBlock = new ConcreteBlock('star', 'B'); $secondBlock = new ConcreteBlock('square', 'E'); $thirdBlock = new ConcreteBlock('square', 'A'); $fourthBlock = new ConcreteBlock('square', 'R'); return [$firstBlock, $secondBlock, $thirdBlock, $fourthBlock]; &#125;&#125; 隨著積木越賣越好，我們會創建出許多Block，它們要顯示的文字各不相同，但形狀大概就那幾種。 我們決定改變積木的實作，不紀錄顯示文字於積木的狀態中。抽離出共用的形狀部分，來節省記憶體的消耗。 首先定義抽象的積木介面 123456789&lt;?phpnamespace App\\Flyweight\\Blocks\\Contracts;interface Block&#123; public function getShape(); public function display(string $word): string;&#125; 之後我們要顯示文字時，會使用display()方法。 接著定義實體積木 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace App\\Flyweight\\Blocks;use App\\Flyweight\\Blocks\\Contracts\\Block;class ConcreteBlock implements Block&#123; /** * @var string */ protected $shape; /** * @param string $shape */ public function __construct(string $shape) &#123; $this-&gt;shape = $shape; &#125; /** * @return string */ public function getShape(): string &#123; return $this-&gt;shape; &#125; /** * @param string $word * @return string */ public function display(string $word): string &#123; return $word; &#125;&#125; 實作積木工廠，採用單例模式來共享 123456789101112131415161718192021222324252627&lt;?phpnamespace App\\Flyweight\\Blocks;use App\\Flyweight\\Blocks\\ConcreteBlock;use App\\Flyweight\\Blocks\\Contracts\\Block;class BlockFactory&#123; /** * @var Block[] */ protected $blocks; /** * @param string $shape * @return ConcreteBlock */ public function getBlock(string $shape): Block &#123; if (!isset($this-&gt;blocks[$shape])) &#123; $this-&gt;blocks[$shape] = new ConcreteBlock($shape); &#125; return $this-&gt;blocks[$shape]; &#125;&#125; 最後修改客戶端的使用方式 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\Flyweight\\Blocks;use App\\Flyweight\\Blocks\\Block;class Program&#123; /** * @return array */ public function getBlocks(): array &#123; $blockFactory = new BlockFactory(); $firstBlock = $blockFactory-&gt;getBlock('star'); // $firstBlock-&gt;display('B'); $secondBlock = $blockFactory-&gt;getBlock('square'); // $secondBlock-&gt;display('E'); $thirdBlock = $blockFactory-&gt;getBlock('square'); // $thirdBlock-&gt;display('A'); $fourthBlock = $blockFactory-&gt;getBlock('square'); // $fourthBlock-&gt;display('R'); return [$firstBlock, $secondBlock, $thirdBlock, $fourthBlock]; &#125;&#125; 當客戶端要顯示文字時，再呼叫display()方法。 \b[單一職責原則]我們將管理內部狀態與管理外部狀態，視為兩種不同的職責。 透過區分兩者，我們便可以用簡單工廠模式搭配單例模式，切出細粒度的物件，來共用相同的程式碼。 其蠅量類別只紀錄內部狀態且創建後便不會改變。 \b[開放封閉原則]透過工廠，我們可以修改積木本身的實作（例如換廠牌），而不影響客戶端。當客戶端修改外部狀態時，也不影響原本純內部狀態的積木。 \b[依賴反轉原則]工廠依賴於抽象的積木介面。實體積木實作了抽象的積木介面。 ʕ •ᴥ•ʔ：原來共享經濟是用了蠅量模式的概念啊。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"蠅量模式","slug":"Flyweight-Pattern","date":"2020-11-01T16:09:33.000Z","updated":"2020-11-02T13:34:05.412Z","comments":true,"path":"2020/11/02/Flyweight-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/11/02/Flyweight-Pattern/","excerpt":"Flyweight Pattern","text":"Flyweight Pattern又稱為享元模式，於相似物件中共享儘可能多的資訊，進而減少記憶體使用量。Example: 文字積木 蠅量模式會將類別分為兩類：分別是**工廠類別 (Factory)與蠅量類別 (Flyweight)**。 透過區分出程式碼的內部狀態與外部狀態，來找出可以共用的程式碼。 將它抽離成蠅量類別，其狀態是**不可變的 (immutable)**。 優點：當擁有許多相似物件時，可節省大量記憶體。 缺點：程式碼複雜度提高。 與其他模式的比較：[單例模式]：兩者的精神皆是透過共用已創建的實例，來節省資源。但蠅量模式的實例狀態是不可變的。 ʕ •ᴥ•ʔ：工廠模式與單例模式的聯合應用技。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：仿真Git （備忘錄模式）","slug":"Class-Diagram-Git-Memento-Pattern","date":"2020-10-26T15:36:16.000Z","updated":"2020-10-30T16:52:03.994Z","comments":true,"path":"2020/10/26/Class-Diagram-Git-Memento-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/10/26/Class-Diagram-Git-Memento-Pattern/","excerpt":"Class Diagram:Git (Memento Pattern)","text":"Example: 仿真Git ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：仿真Git （備忘錄模式）","slug":"Example-Git-Memento-Pattern","date":"2020-10-25T01:06:43.000Z","updated":"2020-11-17T15:56:39.500Z","comments":true,"path":"2020/10/25/Example-Git-Memento-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/10/25/Example-Git-Memento-Pattern/","excerpt":"Example:Git (Memento Pattern)","text":"Pattern: 備忘錄模式 Class Diagram: 仿真Git \b情境：讓我們利用備忘錄模式，實作一個仿真Git 首先定義Commit 1234567891011121314151617181920212223242526&lt;?phpnamespace App\\MementoPattern\\Git;/** * This is our Memento in memento pattern */class Commit&#123; /** * This is our state. * * @var string */ private $code; public function __construct(string $code) &#123; $this-&gt;code = $code; &#125; public function getCode(): string &#123; return $this-&gt;code; &#125;&#125; Commit屬於**備忘錄類別 (Memento)，負責儲存原始類別 (Originator)**的狀態。 在這個範例中，code就是我們的狀態。 接著定義Folder 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App\\MementoPattern\\Git;use App\\MementoPattern\\Git\\Commit;/** * This is our CareTaker in memento pattern */class Folder&#123; /** * @var Commit[] */ private $commits = []; /** * @param Commit $commit */ public function saveCommit(Commit $commit) &#123; $this-&gt;commits[] = $commit; &#125; /** * @param int $previous * @return Commit */ public function getPreviousCommit(int $previous): Commit &#123; $commitAmount = count($this-&gt;commits); $index = $commitAmount - $previous; $result = $this-&gt;commits[$index]; return $result; &#125;&#125; Folder屬於**管理類別 (Caretaker)**，負責管理Commit的存儲。 接著是我們的Git類別 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?phpnamespace App\\MementoPattern\\Git;use App\\MementoPattern\\Git\\Commit;use App\\MementoPattern\\Git\\Folder;/** * This is our Originator in memento pattern */class Git&#123; /** * @var Folder */ protected $folder; /** * This is our state. * * @var string */ private $code; /** * @param Folder $folder */ public function __construct(Folder $folder) &#123; $this-&gt;folder = $folder; &#125; /** * Getter * * @return string */ public function getUntrackedCode(): string &#123; return $this-&gt;code; &#125; /** * Setter * * @var string */ public function writeCode(string $code) &#123; $this-&gt;code = $code; &#125; public function commit() &#123; $commit = $this-&gt;createCommit(); $this-&gt;code = ''; $this-&gt;folder-&gt;saveCommit($commit); &#125; private function createCommit(): Commit &#123; return new Commit($this-&gt;code); &#125; /** * @param int $previous * @return string */ public function reset(int $previous): string &#123; return $this-&gt;code = $this-&gt;folder-&gt;getPreviousCommit($previous)-&gt;getCode(); &#125;&#125; Git屬於我們的**原始類別 (Originator)**，具有code狀態。 getUntrackedCode()及writeCode()是我們code狀態的Getter/Setter。 透過commit()方法，生成Commit，保存了當下code的狀態，並傳給Folder作為紀錄存檔。 透過reset()方法，我們可以載入先前存檔好的code狀態。 最後讓我們看客戶端的程式碼 123456789101112131415161718192021222324252627&lt;?phpnamespace App\\MementoPattern\\Git;use App\\MementoPattern\\Git\\Folder;use App\\MementoPattern\\Git\\Git;class Program&#123; public function run() &#123; $folder = new Folder(); $git = new Git($folder); $git-&gt;writeCode('aaa'); dump($git-&gt;getUntrackedCode()); //aaa $git-&gt;commit(); dump($git-&gt;getUntrackedCode()); //'' $git-&gt;writeCode('bbb'); $git-&gt;commit(); $git-&gt;reset(1); dump($git-&gt;getUntrackedCode()); //aaa &#125;&#125; \b[單一職責原則]我們將原始類別、備忘錄類別與管理類別視為三種職責。 \b[開放封閉原則]透過備忘錄類別與管理類別，原始類別不需要實作恢復狀態的相關功能。 ʕ •ᴥ•ʔ：這個範例只是利用Git作為媒介，與真實Git行為不完全相同。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"備忘錄模式","slug":"Memento-Pattern","date":"2020-10-25T00:50:18.000Z","updated":"2020-10-25T15:52:20.906Z","comments":true,"path":"2020/10/25/Memento-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/10/25/Memento-Pattern/","excerpt":"Memento Pattern","text":"Memento Pattern透過對象外的存檔，讓對象能夠載入之前的狀態。Example: 仿真Git 備忘錄模式會將類別分成三類：分別是**原始類別 (Originator)、備忘錄類別 (Memento)與管理類別 (Caretaker)**。 原始類別為具有內部狀態的標的。備忘錄類別為儲存的原始類別，擁有當時的內部狀態。管理類別負責備忘錄類別的存儲，並留下歷史紀錄。 優點：可以在不破壞封裝性的情況下，保存物件的狀態。可以藉由管理類別，輕易地恢復先前原始類別的狀態。 缺點：當備忘錄類別過多時，會佔用大量的內存。 與其他模式的比較：[命令模式]：命令模式的層級為一道道的不同的命令。備忘錄模式的層級則為原始類別的狀態。 [原型模式]：\b原型模式相當類似備忘錄模式，但缺少了存儲的管理類別。 ʕ •ᴥ•ʔ：玩過RPG遊戲就會理解的模式。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：假期規劃 （建造者模式）","slug":"Class-Diagram-Vacation-Builder-Pattern","date":"2020-10-17T07:51:28.000Z","updated":"2020-10-17T10:09:16.822Z","comments":true,"path":"2020/10/17/Class-Diagram-Vacation-Builder-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/10/17/Class-Diagram-Vacation-Builder-Pattern/","excerpt":"Class Diagram:Vacation (Builder Pattern)","text":"Example: 假期規劃 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：假期規劃 （建造者模式）","slug":"Example-Vacation-Builder-Pattern","date":"2020-10-17T07:51:04.000Z","updated":"2020-10-17T09:47:01.811Z","comments":true,"path":"2020/10/17/Example-Vacation-Builder-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/10/17/Example-Vacation-Builder-Pattern/","excerpt":"Example:Vacation (Builder Pattern)","text":"Pattern: 建造者模式 Class Diagram: 假期規劃 \b情境：目前提供旅遊行程的方式 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App\\BuilderPattern\\Vacation;class Program&#123; /** * @return array */ public function getDomesticTravel() &#123; //高速鐵路一日體驗 return [ 'from' =&gt; 'Kaohsiung', 'to' =&gt; 'Taipei', 'day' =&gt; 1, 'transport' =&gt; 'High Speed Rail' ]; &#125; /** * @return array */ public function getInternationalTravel() &#123; //東京五日遊 return [ 'from' =&gt; 'Kaohsiung', 'to' =&gt; 'Tokyo', 'day' =&gt; 5, 'transport' =&gt; 'Airplane', 'hotel' =&gt; 'Disney Hotel' ]; &#125;&#125; 老闆希望我們能提供更簡便的方式，來規劃不同的旅遊行程。讓我們用建造者模式改造它。 需求一：實作旅遊行程 （產品類別） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?phpnamespace App\\BuilderPattern\\Vacation;class Itinerary&#123; /** * @var string */ protected $from; /** * @var string */ protected $to; /** * @var int */ protected $day; /** * @var string */ protected $hotel; /** * @var string */ protected $transport; /** * @param string $name * @param string|int $value */ public function __set($name, $value) &#123; $this-&gt;$name = $value; &#125; /** * @param string $name * @return string|int */ public function __get($name) &#123; return $this-&gt;$name; &#125; /** * @return array */ public function toArray() &#123; $result = get_object_vars($this); foreach ($result as $name =&gt; $value) &#123; if (is_null($value)) &#123; unset($result[$name]); &#125; &#125; return $result; &#125;&#125; 主要都是getter與setter方法。當行程規劃好時，我們會透過**toArray()**方法來輸出。 需求二：實作行程建造者 （建造者類別） 定義行程規劃介面 1234567891011121314151617181920&lt;?phpnamespace App\\BuilderPattern\\Vacation\\Contracts;use App\\BuilderPattern\\Vacation\\Itinerary;interface ItineraryPlanable&#123; public function from(string $from): self; public function to(string $to): self; public function spendDays(int $day): self; public function stayAt(string $hotel): self; public function travelBy(string $transport): self; public function getItinerary(): Itinerary;&#125; 實作行程建造者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?phpnamespace App\\BuilderPattern\\Vacation;use App\\BuilderPattern\\Vacation\\Itinerary;use App\\BuilderPattern\\Vacation\\Contracts\\ItineraryPlanable;class ItineraryBuilder implements ItineraryPlanable&#123; /** * @var Itinerary */ protected $itinerary; public function __construct() &#123; $this-&gt;itinerary = new Itinerary(); &#125; /** * @param string $from * @return self */ public function from(string $from): self &#123; $this-&gt;itinerary-&gt;from = $from; return $this; &#125; /** * @param string $to * @return self */ public function to(string $to): self &#123; $this-&gt;itinerary-&gt;to = $to; return $this; &#125; /** * @param integer $day * @return self */ public function spendDays(int $day): self &#123; $this-&gt;itinerary-&gt;day = $day; return $this; &#125; /** * @param string $hotel * @return self */ public function stayAt(string $hotel): self &#123; $this-&gt;itinerary-&gt;hotel = $hotel; return $this; &#125; /** * @param string $transport * @return self */ public function travelBy(string $transport): self &#123; $this-&gt;itinerary-&gt;transport = $transport; return $this; &#125; /** * @return Itinerary */ public function getItinerary(): Itinerary &#123; return $this-&gt;itinerary; &#125;&#125; 行程建造者用了**流式接口 (Fluent Interface)**，來增加程式碼可讀性。我們待會會在指揮者類別中展示。 （註：此處也可以實作多個不同的行程建造者，來固定某些行程選項） 需求三：實作旅行社（指揮者類別） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace App\\BuilderPattern\\Vacation;use App\\BuilderPattern\\Vacation\\Contracts\\ItineraryPlanable;class TravelAgency&#123; /** * @var ItineraryPlanable */ protected $itineraryBuilder; public function __construct(ItineraryPlanable $itineraryBuilder) &#123; $this-&gt;itineraryBuilder = $itineraryBuilder; &#125; /** * @return array */ public function getHighSpeedRailItinerary() &#123; $itinerary = $this-&gt;itineraryBuilder -&gt;from('Kaohsiung') -&gt;to('Taipei') -&gt;travelBy('High Speed Rail') -&gt;spendDays(1) -&gt;getItinerary(); return $itinerary-&gt;toArray(); &#125; /** * @return array */ public function getFiveDaysTokyoItinerary() &#123; $itinerary = $this-&gt;itineraryBuilder -&gt;from('Kaohsiung') -&gt;to('Tokyo') -&gt;travelBy('Airplane') -&gt;spendDays(5) -&gt;stayAt('Disney Hotel') -&gt;getItinerary(); return $itinerary-&gt;toArray(); &#125;&#125; 透過旅行社 （指揮者類別），我們封裝了行程的實作。使得客戶端不用知道行程的建造過程。 最後修改原本的程式碼 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\\BuilderPattern\\Vacation;use App\\BuilderPattern\\Vacation\\TravelAgency;use App\\BuilderPattern\\Vacation\\ItineraryBuilder;class Program&#123; /** * @return array */ public function getDomesticTravel() &#123; //高速鐵路一日體驗 $itineraryBuilder = new ItineraryBuilder(); $travelAgency = new TravelAgency($itineraryBuilder); return $travelAgency-&gt;getHighSpeedRailItinerary(); &#125; /** * @return array */ public function getInternationalTravel() &#123; //東京五日遊 $itineraryBuilder = new ItineraryBuilder(); $travelAgency = new TravelAgency($itineraryBuilder); return $travelAgency-&gt;getFiveDaysTokyoItinerary(); &#125;&#125; \b[單一職責原則]我們將指揮者類別、建造者類別與產品類別，視為三種不同的職責。由旅行社指揮行程建造者來構建行程。 \b[開放封閉原則]當新增/修改行程時，我們只要調整指揮者類別。當新增/修改行程內部的邏輯時，我們僅需修改產品類別。 \b[依賴反轉原則]指揮者類別依賴於抽象的建造者介面。建造者類別實作抽象的建造者介面。 ʕ •ᴥ•ʔ：核心精神在於分離建造過程與產品本身的邏輯。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"建造者模式","slug":"Builder-Pattern","date":"2020-10-17T07:48:51.000Z","updated":"2020-10-17T08:44:12.625Z","comments":true,"path":"2020/10/17/Builder-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/10/17/Builder-Pattern/","excerpt":"Builder Pattern","text":"Builder Pattern將複雜對象的構建與其表示分離。Example: 假期規劃 建造者模式會將類別分為三類：分別是指揮者類別 (Director)、建造者類別 (Builder) 與 **產品類別 (Product)**。 通常會透過指揮者來決定建造過程。有時侯會省略指揮者，改由客戶端直接決定建造過程。 優點：可以按步驟，一步步地創建出物件。將創建物件的邏輯與物件本身的邏輯分離。 缺點：會使程式碼變得複雜。 與其他模式的比較：[工廠方法模式]：工廠方法模式中，不同分類的產品都有了對應的工廠。每個不同的選擇都是物件層級。 建造者模式中，分離了建造者與產品。每個不同的選擇都是步驟層級。 而建造者模式常常會搭配**流式接口 (Fluent Interface)的寫作風格。流式接口通常依賴於方法鏈 (Method Chaining)**。 藉由每個方法都回傳物件本身，來增加程式的可讀性。 ʕ •ᴥ•ʔ：Laravel中的query builder，用的就是建造者模式的概念。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：三隻小豬 （原型模式）","slug":"Class-Diagram-Three-Little-Pigs-Prototype-Pattern","date":"2020-10-11T14:38:30.000Z","updated":"2020-10-30T17:11:44.069Z","comments":true,"path":"2020/10/11/Class-Diagram-Three-Little-Pigs-Prototype-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/10/11/Class-Diagram-Three-Little-Pigs-Prototype-Pattern/","excerpt":"Class Diagram:Three Little Pigs (Prototype Pattern)","text":"Example: 三隻小豬 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：三隻小豬 （原型模式）","slug":"Example-Three-Little-Pigs-Prototype-Pattern","date":"2020-10-11T14:38:14.000Z","updated":"2020-10-30T17:09:32.334Z","comments":true,"path":"2020/10/11/Example-Three-Little-Pigs-Prototype-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/10/11/Example-Three-Little-Pigs-Prototype-Pattern/","excerpt":"Example:Three Little Pigs (Prototype Pattern)","text":"Pattern: 原型模式 Class Diagram: 三隻小豬 情境：三隻小豬想要蓋房子 首先是牆壁，可以選擇不同的建材 12345678910111213141516&lt;?phpnamespace App\\PrototypePattern\\Building;class Wall&#123; /** * @var string */ public $material; public function __construct(string $material) &#123; $this-&gt;material = $material; &#125;&#125; 接著是房子 12345678910111213141516171819202122232425262728&lt;?phpnamespace App\\PrototypePattern\\Building;use App\\PrototypePattern\\Building\\Wall;class Building&#123; /** * @var string */ public $name; /** * @var Wall */ public $wall; /** * @param Wall $wall * @param string $name */ public function __construct(Wall $wall, string $name = 'unnamed') &#123; $this-&gt;wall = $wall; $this-&gt;name = $name; &#125;&#125; 接著豬大哥用**稻草 (straw)**，蓋了間稻草屋 12345678910111213141516171819202122&lt;?phpnamespace App\\PrototypePattern\\Building;use App\\PrototypePattern\\Building\\Building;use App\\PrototypePattern\\Building\\Wall;class Program&#123; /** * @return array */ public function run() &#123; //firstBuilding $strawWall = new Wall('straw'); $firstBuilding = new Building($strawWall, 'oldestPigHouse'); dump($firstBuilding-&gt;name); // oldestPigHouse dump($firstBuilding-&gt;wall-&gt;material); // straw &#125;&#125; 完成後，豬大哥很得意自己對房子的設計，詢問弟弟們要不要直接拷貝一間。 需求一：拷貝豬大哥的稻草屋 兩個弟弟想了想，拷貝大哥的房子，好像是個省事的方法，但二弟想用木材 (wood)，三弟想用磚塊 (bricks) 來蓋房子。 決定拷貝稻草屋的弟弟們 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace App\\PrototypePattern\\Building;use App\\PrototypePattern\\Building\\Building;use App\\PrototypePattern\\Building\\Wall;class Program&#123; /** * @return array */ public function run() &#123; //firstBuilding $strawWall = new Wall('straw'); $firstBuilding = new Building($strawWall, 'oldestPigHouse'); //secondBuilding $secondBuilding = clone $firstBuilding; $secondBuilding-&gt;name = 'middlePigHouse'; $secondBuilding-&gt;wall-&gt;material = 'wood'; //thirdBuilding $thirdBuilding = clone $firstBuilding; $thirdBuilding-&gt;name = 'youngestPigHouse'; $thirdBuilding-&gt;wall-&gt;material = 'bricks'; dump($firstBuilding-&gt;name); // oldestPigHouse dump($firstBuilding-&gt;wall-&gt;material); // bricks dump($secondBuilding-&gt;name); // middlePigHouse dump($secondBuilding-&gt;wall-&gt;material); // bricks dump($thirdBuilding-&gt;name); // youngestPigHouse dump($thirdBuilding-&gt;wall-&gt;material); // bricks return [ 'firstBuilding' =&gt; $firstBuilding, 'secondBuilding' =&gt; $secondBuilding, 'thirdBuilding' =&gt; $thirdBuilding ]; &#125;&#125; 這時發生了件很尷尬的事情，當豬二哥選用木材當建材時，大哥的稻草屋就變成木頭屋了…而豬小弟選用磚塊當建材時，兩個哥哥們的房子就變成磚頭屋了… 導演表示，這樣故事沒辦法進行下去，請我們修改一下。 需求二：讓弟弟們對建材的修改，不會影響到哥哥 修改Building中的clone()方法，讓拷貝時能重新創建牆壁 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\\PrototypePattern\\Building;use App\\PrototypePattern\\Building\\Wall;class Building&#123; /** * @var string */ public $name; /** * @var Wall */ public $wall; /** * @param Wall $wall * @param string $name */ public function __construct(Wall $wall, string $name = 'unnamed') &#123; $this-&gt;wall = $wall; $this-&gt;name = $name; &#125; public function __clone() &#123; $this-&gt;wall = clone $this-&gt;wall; &#125;&#125; 不用修改原本的程式碼 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace App\\PrototypePattern\\Building;use App\\PrototypePattern\\Building\\Building;use App\\PrototypePattern\\Building\\Wall;class Program&#123; /** * @return array */ public function run() &#123; //firstBuilding $strawWall = new Wall('straw'); $firstBuilding = new Building($strawWall, 'oldestPigHouse'); //secondBuilding $secondBuilding = clone $firstBuilding; $secondBuilding-&gt;name = 'middlePigHouse'; $secondBuilding-&gt;wall-&gt;material = 'wood'; //thirdBuilding $thirdBuilding = clone $firstBuilding; $thirdBuilding-&gt;name = 'youngestPigHouse'; $thirdBuilding-&gt;wall-&gt;material = 'bricks'; dump($firstBuilding-&gt;name); // oldestPigHouse dump($firstBuilding-&gt;wall-&gt;material); // straw dump($secondBuilding-&gt;name); // middlePigHouse dump($secondBuilding-&gt;wall-&gt;material); // wood dump($thirdBuilding-&gt;name); // youngestPigHouse dump($thirdBuilding-&gt;wall-&gt;material); // bricks return [ 'firstBuilding' =&gt; $firstBuilding, 'secondBuilding' =&gt; $secondBuilding, 'thirdBuilding' =&gt; $thirdBuilding ]; &#125;&#125; 後來弟弟們改用其他建材時，就不會影響到原本哥哥的房子了。 這就是淺複製 (Shallow Copy) 與深複製 (Deep Copy) 的不同。 後來三隻小豬跑去開建設公司，又是另一個故事了。 ʕ •ᴥ•ʔ：一開始clone()方法能直接使用，是因為PHP的魔術方法__clone()唷！","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"原型模式","slug":"Prototype-Pattern","date":"2020-10-11T14:37:18.000Z","updated":"2020-10-30T17:01:29.229Z","comments":true,"path":"2020/10/11/Prototype-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/10/11/Prototype-Pattern/","excerpt":"Prototype Pattern","text":"Prototype Pattern當創建實例的過程很昂貴或複雜時，透過拷貝這些原型來建立新的實例。Example: 三隻小豬 原型模式中會將類別分為兩類：分別是原型介面 (Prototype) 及**具體原型類別 (Concrete Prototype)**。 透過原型介面，我們可以知道該實例能**拷貝 (clone)**，複製出自己的實例。 其中拷貝又可分為兩種：分別是淺複製 (Shallow Copy) 與**深複製 (Deep Copy)**。 兩者的差別在於，當原型類別的屬性為參考類型 (references) 時，淺複製會指向與實例一樣的位址，不會重新創建屬性。深複製則會重新創建屬性。 這意味著，當使用淺複製時，修改參考類型的屬性會一併修改到原本實例。 優點：可以直接拷貝實例，省去創建的麻煩。也提供了一個不使用繼承 (extend) 來面對複雜實例的方式。 缺點：當架構較為複雜時，深複製可能會不好實作。 與其他模式的比較：[抽象工廠模式]：抽象工廠模式，透過定義產品族的概念，處理複雜的創建。原型模式則是想利用拷貝的概念，來處理複雜的創建。 [單例模式]：單例模式保證同一時間存在一個實例。原型模式則是複製出一個實例。 ʕ •ᴥ•ʔ：在PHP中，由於有魔術方法__clone()的存在，我們可以不定義原型介面，直接使用clone()。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：快取代理（代理模式）","slug":"Class-Diagram-Cache-Proxy-Pattern","date":"2020-10-04T13:21:32.000Z","updated":"2020-10-04T14:08:31.921Z","comments":true,"path":"2020/10/04/Class-Diagram-Cache-Proxy-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/10/04/Class-Diagram-Cache-Proxy-Pattern/","excerpt":"Class Diagram:Cache (Proxy Pattern)","text":"Example: 快取代理 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：快取代理（代理模式）","slug":"Example-Cache-Proxy-Pattern","date":"2020-10-04T12:16:55.000Z","updated":"2020-10-19T15:50:23.590Z","comments":true,"path":"2020/10/04/Example-Cache-Proxy-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/10/04/Example-Cache-Proxy-Pattern/","excerpt":"Example:Cache (Proxy Pattern)","text":"Pattern: 代理模式 Class Diagram: 快取代理 情境：以下是某搜尋功能 客戶端程式碼 123456789101112131415161718192021222324252627&lt;?phpnamespace App\\ProxyPattern\\Cache;use App\\ProxyPattern\\Cache\\Database;class Program&#123; /** * @var Database */ protected $database; public function __construct() &#123; $this-&gt;database = new Database(); &#125; /** * @param string $keyword * @return array */ public function search(string $keyword): array &#123; return $this-&gt;database-&gt;read($keyword); &#125;&#125; 實體資料庫（供存取資料用） 12345678910111213141516171819&lt;?phpnamespace App\\ProxyPattern\\Cache;class Database&#123; /** * @param string $keyword * @return array */ public function read(string $keyword): array &#123; if ($keyword == 'sushi') &#123; return ['Bear Sushi', 'Lin Sushi', 'Alysa Sushi']; &#125; return []; &#125;&#125; 老闆希望搜尋時，若是已搜尋過的資料，便由快取返回，不再呼叫實體資料庫。 讓我們用代理模式改造它。 需求一：實現快取代理 首先定義讀取介面 123456789101112&lt;?phpnamespace App\\ProxyPattern\\Cache\\Contracts;interface Readable&#123; /** * @param string $keyword * @return array */ public function read(string $keyword): array;&#125; 實體資料庫實現讀取介面 123456789101112131415161718192021&lt;?phpnamespace App\\ProxyPattern\\Cache;use App\\ProxyPattern\\Cache\\Contracts\\Readable;class Database implements Readable&#123; /** * @param string $keyword * @return array */ public function read(string $keyword): array &#123; if ($keyword == 'sushi') &#123; return ['Bear Sushi', 'Lin Sushi', 'Alysa Sushi']; &#125; return []; &#125;&#125; 實作快取代理 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace App\\ProxyPattern\\Cache;use App\\ProxyPattern\\Cache\\Contracts\\Readable;class CacheProxy implements Readable&#123; /** * @var array */ protected $cached = []; /** * @var Database */ protected $database; public function __construct() &#123; $this-&gt;database = new Database(); &#125; /** * @param string $keyword * @return array */ public function read(string $keyword): array &#123; if (isset($this-&gt;cached[$keyword])) &#123; return $this-&gt;cached[$keyword]; &#125; $result = $this-&gt;database-&gt;read($keyword); $this-&gt;cached[$keyword] = $result; return $result; &#125;&#125; 修改客戶端程式碼 123456789101112131415161718192021222324252627&lt;?phpnamespace App\\ProxyPattern\\Cache;use App\\ProxyPattern\\Cache\\CacheProxy;class Program&#123; /** * @var CacheProxy */ protected $proxy; public function __construct() &#123; $this-&gt;proxy = new CacheProxy(); &#125; /** * @param string $keyword * @return array */ public function search(string $keyword): array &#123; return $this-&gt;proxy-&gt;read($keyword); &#125;&#125; 這下子客戶端搜尋時，若快取代理有資料，便會直接返回結果。 \b[單一職責原則]我們將實體類別與代理類別視作兩種不同的職責。代理類別主要處理訪問實體類別的行為。 \b[開放封閉原則]當我們需要實現不屬於實體類別的職責時（例如：關鍵字被搜尋次數），我們可以在代理類別中實現，不須修改實體類別的程式碼。 若有需要其他控制訪問的職責時，也可以新增代理類別。 除了上述的提出介面的委派方法外，也有人用繼承的手法修改行為，但我個人比較不喜歡。 ʕ •ᴥ•ʔ：代理類別就像是實體類別的經紀人一樣。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"代理模式","slug":"Proxy-Pattern","date":"2020-10-04T12:13:02.000Z","updated":"2020-11-18T14:40:56.596Z","comments":true,"path":"2020/10/04/Proxy-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/10/04/Proxy-Pattern/","excerpt":"Proxy Pattern","text":"Proxy Pattern為另一個對象提供一個替身或佔位符以控制這個對象的訪問。Example: 快取代理 代理模式將類別分為兩類：分別是**實體類別 (RealSubject)與代理類別 (Proxy)**。 代理類別會與實體類別實現相同的介面，且保存對實體類別的引用。 優點：控制訪問的職責，不必寫在實體類別。有了代理類別，可以**延遲實例化 (lazy initialization)**實體類別。可以有多種控制訪問實體類別的方式。可以在實體類別被訪問時，做一些額外的事（不屬於實體類別的職責）。 缺點：程式碼複雜度提高。回應可能會有所延遲。 與其他模式的比較：[轉接頭模式]：轉接頭模式只負責轉化不同介面間的關係。而代理模式則是實現相同的介面，處理更多訪問相關的職責。 [裝飾者模式]：裝飾者模式豐富既有行為時，原因較常是來自客戶端。而代理模式豐富既有行為時，原因較常是來自服務端。 [外觀模式]：外觀模式的目的是提供簡化接口。而代理模式的目的則是控制訪問行為。 常見的使用場景： 遠端代理：控制訪問遠程對象，利用網路轉發到遠程執行。 虛擬代理：控制訪問創建開銷大的對象，待客戶端有請求時才進行實例化。 安全代理：控制訪問對象的許可權。 智慧代理：處理訪問對象時，不屬於訪問對象的職責。 ʕ •ᴥ•ʔ：當想控制訪問對象時，很可能就是使用代理模式的時機。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：歌曲排行（迭代器模式）","slug":"Class-Diagram-Top-Song-Iterator-Pattern","date":"2020-09-28T04:22:49.000Z","updated":"2020-10-19T15:46:41.578Z","comments":true,"path":"2020/09/28/Class-Diagram-Top-Song-Iterator-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/09/28/Class-Diagram-Top-Song-Iterator-Pattern/","excerpt":"Class Diagram:Top Song (Iterator Pattern)","text":"Example: 歌曲排行 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：歌曲排行（迭代器模式）","slug":"Example-Top-Song-Iterator-Pattern","date":"2020-09-27T14:54:35.000Z","updated":"2020-10-18T11:50:10.825Z","comments":true,"path":"2020/09/27/Example-Top-Song-Iterator-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/09/27/Example-Top-Song-Iterator-Pattern/","excerpt":"Example:Top Song (Iterator Pattern)","text":"Pattern: 迭代器模式 Class Diagram: 歌曲排行 需求一：KTV系統要按照新增到系統的時間，由舊到新，實作歌曲排行 定義系統存取歌曲的類別（解析傳進來的data） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpnamespace App\\IteratorPattern\\TopSong;use DateTime;class Song&#123; /** * @var string */ protected $name; /** * @var string */ protected $singer; /** * @var DateTime */ protected $releaseDate; public function __construct(array $data) &#123; $this-&gt;name = $data['name']; $this-&gt;singer = $data['singer']; $this-&gt;releaseDate = new DateTime($data['releaseDate']); &#125; /** * @return string */ public function getName() &#123; return $this-&gt;name; &#125; /** * @return string */ public function getSinger() &#123; return $this-&gt;singer; &#125; /** * @return DateTime */ public function getReleaseDate() &#123; return $this-&gt;releaseDate; &#125;&#125; 定義歌曲集合 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpnamespace App\\IteratorPattern\\TopSong;class SongCollection&#123; /** * @var Song[] */ protected $items = []; public function __construct(array $originalSongs) &#123; $this-&gt;items = $this-&gt;generateSongs($originalSongs); &#125; /** * @param array $originalSongs * @return Song[] */ private function generateSongs($originalSongs) &#123; $result = []; foreach ($originalSongs as $originalSong) &#123; $result[] = new Song($originalSong); &#125; return $result; &#125; /** * @return Song[] */ public function getItems() &#123; return $this-&gt;items; &#125; /** * @return array */ public function list() &#123; foreach ($this-&gt;items as $item) &#123; $result[] = $item-&gt;getName(); &#125; return $result; &#125;&#125; SongCollection就是迭代器模式中的**集合類別 (Aggregate / Collection)**。不過我們目前還沒實作PHP的IteratorAggregate介面。 而generateSongs()的目的，是為了將不同來源的歌曲資訊，轉換成系統認識的Song類別。 目前遍歷的程式碼 1234567891011121314151617181920212223&lt;?phpnamespace App\\IteratorPattern\\TopSong;use App\\IteratorPattern\\TopSong\\SongCollection;class Program&#123; /** * @var SongCollection */ protected $songCollection; public function __construct(array $songs) &#123; $this-&gt;songCollection = new SongCollection($songs); &#125; public function list() &#123; return $this-&gt;songCollection-&gt;list(); &#125;&#125; 目前的list()方法，很單純只用到foreach而已。接著用迭代器模式改寫它。 首先實作迭代器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?phpnamespace App\\IteratorPattern\\TopSong;use App\\IteratorPattern\\TopSong\\SongCollection;use Iterator;class SongIterator implements Iterator&#123; /** * @var SongCollection */ protected $collection; /** * @var int */ private $position = 0; public function __construct(SongCollection $collection) &#123; $this-&gt;collection = $collection; &#125; /** * Return the current element * * @return Song */ public function current() &#123; return $this-&gt;collection-&gt;getItems()[$this-&gt;position]; &#125; /** * Return the key of the current element * * @return int */ public function key() &#123; return $this-&gt;position; &#125; /** * Move forward to next element * * @return void */ public function next() &#123; $this-&gt;position++; &#125; /** * Rewind the Iterator to the first element * * @return int */ public function rewind() &#123; $this-&gt;position = 0; &#125; /** * Checks if current position is valid * * @return void */ public function valid() &#123; return isset($this-&gt;collection-&gt;getItems()[$this-&gt;position]); &#125;&#125; SongIterator就是迭代器模式中的**迭代器類別 (Iterator)**。我們實作了PHP的Iterator介面。 必須實作current, key, next, rewind, valid方法，其目的都有寫在PHPDoc中。而我們在建構式中將剛剛的SongCollection注入。 改寫SongCollection 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace App\\IteratorPattern\\TopSong;use IteratorAggregate;use Traversable;class SongCollection implements IteratorAggregate&#123; /** * @var Song[] */ protected $items = []; public function __construct(array $dataOfSongs) &#123; $this-&gt;items = $this-&gt;generateSongs($dataOfSongs); &#125; /** * @param array $dataOfSongs * @return Song[] */ private function generateSongs($dataOfSongs) &#123; foreach ($dataOfSongs as $dataOfSong) &#123; $result[] = new Song($dataOfSong); &#125; return $result; &#125; /** * @return Song[] */ public function getItems() &#123; return $this-&gt;items; &#125; public function getIterator(): Traversable &#123; return new SongIterator($this); &#125;&#125; 我們實作了PHP的IteratorAggregate介面。 getIterator()方法會將當前的SongCollection注入，並回傳SongIterator。 最後改寫遍歷的程式碼 12345678910111213141516171819202122232425262728&lt;?phpnamespace App\\IteratorPattern\\TopSong;use App\\IteratorPattern\\TopSong\\SongCollection;class Program&#123; /** * @var SongCollection */ protected $songCollection; public function __construct(array $songs) &#123; $this-&gt;songCollection = new SongCollection($songs); &#125; public function list() &#123; $iterator = $this-&gt;songCollection-&gt;getIterator(); foreach ($iterator as $item) &#123; $result[] = $item-&gt;getName(); &#125; return $result; &#125;&#125; 需求二：按照新增到系統的時間，由新到舊，實作歌曲排行 修改SongCollection，新增reverse()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpnamespace App\\IteratorPattern\\TopSong;use IteratorAggregate;use Traversable;class SongCollection implements IteratorAggregate&#123; /** * @var array */ protected $dataOfSongs; /** * @var Song[] */ protected $items = []; public function __construct(array $dataOfSongs) &#123; $this-&gt;dataOfSongs = $dataOfSongs; $this-&gt;items = $this-&gt;generateSongs($dataOfSongs); &#125; /** * @param array $dataOfSongs * @return Song[] */ private function generateSongs($dataOfSongs) &#123; foreach ($dataOfSongs as $dataOfSong) &#123; $result[] = new Song($dataOfSong); &#125; return $result; &#125; /** * @return Song[] */ public function getItems() &#123; return $this-&gt;items; &#125; public function getIterator(): Traversable &#123; return new SongIterator($this); &#125; /** * @return static */ public function reverse() &#123; return new static(array_reverse($this-&gt;dataOfSongs)); &#125;&#125; 這邊的reverse()方法，會將原始資料倒序後，回傳一個新的SongCollection。 修改遍歷的程式碼，新增listReverse()方法 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace App\\IteratorPattern\\TopSong;use App\\IteratorPattern\\TopSong\\SongCollection;class Program&#123; /** * @var SongCollection */ protected $songCollection; public function __construct(array $songs) &#123; $this-&gt;songCollection = new SongCollection($songs); &#125; public function list() &#123; $iterator = $this-&gt;songCollection-&gt;getIterator(); foreach ($iterator as $item) &#123; $result[] = $item-&gt;getName(); &#125; return $result; &#125; public function listReverse() &#123; $iterator = $this-&gt;songCollection-&gt;reverse()-&gt;getIterator(); foreach ($iterator as $item) &#123; $result[] = $item-&gt;getName(); &#125; return $result; &#125;&#125; [單一職責原則]將**集合元素 (Song)、集合類別 (SongCollection)及迭代器 (SongIterator)**的職責分離。 \b[開放封閉原則]無論是修改集合元素，或是迭代順序，我們都不會改到所有的程式碼。 [介面隔離原則]定義出集合類別介面與迭代器介面，讓兩者不會互相影響。 [依賴反轉原則]透過集合類別介面與迭代器介面，確保有取得迭代器及foreach()的能力。 ʕ •ᴥ•ʔ：一個讓我枯坐在翰林茶館兩個小時的模式（汗）。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"迭代器模式","slug":"Iterator-Pattern","date":"2020-09-27T10:07:17.000Z","updated":"2020-10-12T16:07:56.174Z","comments":true,"path":"2020/09/27/Iterator-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/09/27/Iterator-Pattern/","excerpt":"Iterator Pattern","text":"Iterator Pattern提供一種方法順序訪問一個聚合對象中的各個元素，而又不暴露其內部的表示。Example: 歌曲排行 迭代器模式會將類別分為兩類：分別是**集合類別 (Aggregate / Collection)及迭代器類別 (Iterator)**。 集合類別負責提供統一介面，供所有集合元素使用，使客戶與集合元素的實現解耦。 迭代器類別則負責提供在集合元素中遊走的方法。 舉例：集合元素 -&gt; 集合類別歌曲 -&gt; 歌單菜式 -&gt; 菜單書本 -&gt; 書單 優點：分離了集合物件的遍歷行為，可以在不暴露集合內部的情況下，供外部存取。新增/修改遍歷規則時，不會影響到集合元素。 缺點：若只是簡單的遍歷，可能會是一種過度設計。 其實此模式的實現，現在大都已被封裝，只要實現對應的介面就好了。 以PHP而言，主要有以下幾個介面與迭代器模式有關。 介面名稱 用途 Traversable 所有迭代器介面的源頭，主要用來判斷能不能用foreach遍歷。 IteratorAggregate 集合類別的介面，主要用來提供迭代器，需與Iterator介面一起實作。 Iterator 迭代器的介面，定義了遍歷時會用到的方法，需與IteratorAggregate介面一起實作。 其他SPL (Standard PHP Library) 的Iterator。 ʕ •ᴥ•ʔ：讓我們一起欣賞這個古老的模式！","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"範例：電力系統（依賴反轉原則）","slug":"Example-Power-Systems-Dependency-Inversion-Principle","date":"2020-09-21T02:48:11.000Z","updated":"2020-09-21T04:35:06.319Z","comments":true,"path":"2020/09/21/Example-Power-Systems-Dependency-Inversion-Principle/","link":"","permalink":"https://yncbearz.github.io/2020/09/21/Example-Power-Systems-Dependency-Inversion-Principle/","excerpt":"Example:Power Systems (Dependency Inversion Principle)","text":"Principle: 依賴反轉原則 情境：目前電力系統採用火力發電 火力發電 1234567891011&lt;?phpnamespace App\\SOLID\\DIP\\PowerSystems;class ThermalPower&#123; public function generatePower() &#123; return '電力'; &#125;&#125; 電力系統 1234567891011121314&lt;?phpnamespace App\\SOLID\\DIP\\PowerSystems;use App\\SOLID\\DIP\\PowerSystems\\ThermalPower;class Program&#123; public function getPower() &#123; $thermalPower = new ThermalPower(); return $thermalPower-&gt;generatePower(); &#125;&#125; 隨著科技發展，現在我們想要改成用風力發電來取代火力發電，卻發現原本的程式，強耦合在ThermalPower。（依賴了具體的類別） 我們決定定義一個抽象的介面，讓程式依賴在介面，並由各個發電方式實作介面。改變彼此的依賴關係。 需求一：定義抽象介面，改變電力系統與火力發電的依賴關係 首先定義發電介面 12345678&lt;?phpnamespace App\\SOLID\\DIP\\PowerSystems\\Contracts;interface PowerGeneratable&#123; public function generatePower();&#125; 接著讓火力發電實作發電介面 12345678910111213&lt;?phpnamespace App\\SOLID\\DIP\\PowerSystems;use App\\SOLID\\DIP\\PowerSystems\\Contracts\\PowerGeneratable;class ThermalPower implements PowerGeneratable&#123; public function generatePower() &#123; return '電力'; &#125;&#125; 最後改寫原本的電力系統 12345678910111213&lt;?phpnamespace App\\SOLID\\DIP\\PowerSystems;use App\\SOLID\\DIP\\PowerSystems\\Contracts\\PowerGeneratable;class Program&#123; public function getPower(PowerGeneratable $powerGeneration) &#123; return $powerGeneration-&gt;generatePower(); &#125;&#125; （註：現在要用什麼樣的發電方式，會交由客戶端決定） 客戶端使用火力發電（提供測試程式碼，供參考） 12345678910111213141516171819202122232425262728&lt;?phpnamespace Tests\\Feature\\SOLID\\DIP\\PowerSystems;use PHPUnit\\Framework\\TestCase;use App\\SOLID\\DIP\\PowerSystems\\Program;use App\\SOLID\\DIP\\PowerSystems\\ThermalPower;class ProgramTest extends TestCase&#123; /** * @var Program */ protected $sut; protected function setUp(): void &#123; $this-&gt;sut = new Program(); &#125; public function testGetPowerByThermalPower() &#123; $expected = '電力'; $powerGeneration = new ThermalPower(); $actual = $this-&gt;sut-&gt;getPower($powerGeneration); $this-&gt;assertEquals($expected, $actual); &#125;&#125; 需求二：新增風力發電 實作風力發電 12345678910111213&lt;?phpnamespace App\\SOLID\\DIP\\PowerSystems;use App\\SOLID\\DIP\\PowerSystems\\Contracts\\PowerGeneratable;class WindPower implements PowerGeneratable&#123; public function generatePower() &#123; return '電力'; &#125;&#125; 客戶端使用風力發電（提供測試程式碼，供參考） 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace Tests\\Feature\\SOLID\\DIP\\PowerSystems;use PHPUnit\\Framework\\TestCase;use App\\SOLID\\DIP\\PowerSystems\\Program;use App\\SOLID\\DIP\\PowerSystems\\ThermalPower;use App\\SOLID\\DIP\\PowerSystems\\WindPower;class ProgramTest extends TestCase&#123; /** * @var Program */ protected $sut; protected function setUp(): void &#123; $this-&gt;sut = new Program(); &#125; public function testGetPowerByThermalPower() &#123; $expected = '電力'; $powerGeneration = new ThermalPower(); $actual = $this-&gt;sut-&gt;getPower($powerGeneration); $this-&gt;assertEquals($expected, $actual); &#125; public function testGetPowerByWindPower() &#123; $expected = '電力'; $powerGeneration = new WindPower(); $actual = $this-&gt;sut-&gt;getPower($powerGeneration); $this-&gt;assertEquals($expected, $actual); &#125;&#125; 最後附上類別圖比較： 依賴具體的火力發電 依賴抽象的發電介面，並由各個發現方式實作介面（可以觀察火力發電與風力發電的依賴方向，是不是反轉了呢） ʕ •ᴥ•ʔ：透過遵守依賴反轉原則，我們也讓程式符合開放封閉原則。","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://yncbearz.github.io/categories/Clean-Code/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"範例：咖啡機（介面隔離原則）","slug":"Example-Coffee-Machine-Interface-Segregation-Principle","date":"2020-09-19T15:42:00.000Z","updated":"2020-09-20T15:51:10.816Z","comments":true,"path":"2020/09/19/Example-Coffee-Machine-Interface-Segregation-Principle/","link":"","permalink":"https://yncbearz.github.io/2020/09/19/Example-Coffee-Machine-Interface-Segregation-Principle/","excerpt":"Example:Coffee Machine (Interface Segregation Principle)","text":"Principle: 介面隔離原則 情境：目前我們有一台全自動咖啡機 首先定義全自動咖啡機介面 12345678910&lt;?phpnamespace App\\SOLID\\ISP\\CoffeeMachine\\Contracts;interface AutomaticCoffeeMachineInterface&#123; public function grind($coffeeBeans); public function brew($coffeePowder);&#125; 接著是全自動咖啡機 12345678910111213141516171819202122&lt;?phpnamespace App\\SOLID\\ISP\\CoffeeMachine;use App\\SOLID\\ISP\\CoffeeMachine\\Contracts\\AutomaticCoffeeMachineInterface;class AutomaticCoffeeMachine implements AutomaticCoffeeMachineInterface&#123; public function grind($coffeeBeans) &#123; if ($coffeeBeans == '咖啡豆') &#123; return '咖啡粉'; &#125; &#125; public function brew($coffeePowder) &#123; if ($coffeePowder == '咖啡粉') &#123; return '咖啡'; &#125; &#125;&#125; 最後是目前的沖煮方式 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace App\\SOLID\\ISP\\CoffeeMachine;class Program&#123; protected $coffeeGrinder; protected $coffeeMaker; public function getCoffeeByAutomaticCoffeeMachine($coffeeBeans) &#123; $automaticCoffeeMachine = new AutomaticCoffeeMachine(); $this-&gt;coffeeGrinder = $automaticCoffeeMachine; $this-&gt;coffeeMaker = $automaticCoffeeMachine; return $this-&gt;getCoffee($coffeeBeans); &#125; private function grind($coffeeBeans) &#123; return $this-&gt;coffeeGrinder-&gt;grind($coffeeBeans); &#125; private function brew($coffeePowder) &#123; return $this-&gt;coffeeMaker-&gt;brew($coffeePowder); &#125; private function getCoffee($coffeeBeans) &#123; $coffeePowder = $this-&gt;grind($coffeeBeans); $coffee = $this-&gt;brew($coffeePowder); return $coffee; &#125;&#125; 然而，隨著對咖啡興趣增加，我們想來玩玩摩卡壺。卻發現摩卡壺不會磨粉… 需求一：將全自動咖啡機介面職責分離，拆分出磨粉介面與沖煮介面 首先定義磨粉介面 12345678&lt;?phpnamespace App\\SOLID\\ISP\\CoffeeMachine\\Contracts;interface CoffeeGrinder&#123; public function grind($coffeeBeans);&#125; 接著定義沖煮介面 12345678&lt;?phpnamespace App\\SOLID\\ISP\\CoffeeMachine\\Contracts;interface CoffeeMaker&#123; public function brew($coffeePowder);&#125; 最後修改原本的全自動咖啡機，讓它實作新的兩個介面 1234567891011121314151617181920212223&lt;?phpnamespace App\\SOLID\\ISP\\CoffeeMachine;use App\\SOLID\\ISP\\CoffeeMachine\\Contracts\\CoffeeGrinder;use App\\SOLID\\ISP\\CoffeeMachine\\Contracts\\CoffeeMaker;class AutomaticCoffeeMachine implements CoffeeGrinder, CoffeeMaker&#123; public function grind($coffeeBeans) &#123; if ($coffeeBeans == '咖啡豆') &#123; return '咖啡粉'; &#125; &#125; public function brew($coffeePowder) &#123; if ($coffeePowder == '咖啡粉') &#123; return '咖啡'; &#125; &#125;&#125; 需求二：實作磨豆機與摩卡壺 實作磨豆機（因為拆分出沖煮介面，它不需要知道如何沖煮） 123456789101112131415&lt;?phpnamespace App\\SOLID\\ISP\\CoffeeMachine;use App\\SOLID\\ISP\\CoffeeMachine\\Contracts\\CoffeeGrinder;class NormalCoffeeGrinder implements CoffeeGrinder&#123; public function grind($coffeeBeans) &#123; if ($coffeeBeans == '咖啡豆') &#123; return '咖啡粉'; &#125; &#125;&#125; 實作摩卡壺（因為拆分出磨豆介面，它不需要知道如何磨豆） 123456789101112131415&lt;?phpnamespace App\\SOLID\\ISP\\CoffeeMachine;use App\\SOLID\\ISP\\CoffeeMachine\\Contracts\\CoffeeMaker;class Mocalpot implements CoffeeMaker&#123; public function brew($coffeePowder) &#123; if ($coffeePowder == '咖啡粉') &#123; return '咖啡'; &#125; &#125;&#125; 最後新增煮咖啡的方法，用磨豆機與摩卡壺的組合 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpnamespace App\\SOLID\\ISP\\CoffeeMachine;use App\\SOLID\\ISP\\CoffeeMachine\\Contracts\\CoffeeGrinder;use App\\SOLID\\ISP\\CoffeeMachine\\Contracts\\CoffeeMaker;use App\\SOLID\\ISP\\CoffeeMachine\\NormalCoffeeGrinder;use App\\SOLID\\ISP\\CoffeeMachine\\MocalPot;class Program&#123; /** * @var CoffeeGrinder */ protected $coffeeGrinder; /** * @var CoffeeMaker */ protected $coffeeMaker; public function getCoffeeByAutomaticCoffeeMachine($coffeeBeans) &#123; $automaticCoffeeMachine = new AutomaticCoffeeMachine(); $this-&gt;setCoffeeGrinder($automaticCoffeeMachine); $this-&gt;setCoffeeMaker($automaticCoffeeMachine); return $this-&gt;getCoffee($coffeeBeans); &#125; public function getCoffeeByNormalCoffeeGrinderAndMocalPot($coffeeBeans) &#123; $normalCoffeeGrinder = new NormalCoffeeGrinder(); $mocalPot = new MocalPot(); $this-&gt;setCoffeeGrinder($normalCoffeeGrinder); $this-&gt;setCoffeeMaker($mocalPot); return $this-&gt;getCoffee($coffeeBeans); &#125; private function grind($coffeeBeans) &#123; return $this-&gt;coffeeGrinder-&gt;grind($coffeeBeans); &#125; private function brew($coffeePowder) &#123; return $this-&gt;coffeeMaker-&gt;brew($coffeePowder); &#125; private function getCoffee($coffeeBeans) &#123; $coffeePowder = $this-&gt;grind($coffeeBeans); $coffee = $this-&gt;brew($coffeePowder); return $coffee; &#125; private function setCoffeeGrinder(CoffeeGrinder $coffeeGrinder) &#123; $this-&gt;coffeeGrinder = $coffeeGrinder; &#125; private function setCoffeeMaker(CoffeeMaker $coffeeMaker) &#123; $this-&gt;coffeeMaker = $coffeeMaker; &#125;&#125; ʕ •ᴥ•ʔ：運用介面隔離原則拆分介面職責，我們就可以玩更多花樣的咖啡沖煮方法了。 而煮咖啡方法也不必因為器具更換而修改。符合開放封閉原則。","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://yncbearz.github.io/categories/Clean-Code/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"範例：老爸餐廳（裡氏替換原則）","slug":"Example-Dad-Restaurant-Liskov-Substitution-Principle","date":"2020-09-19T06:23:08.000Z","updated":"2020-09-20T15:51:03.180Z","comments":true,"path":"2020/09/19/Example-Dad-Restaurant-Liskov-Substitution-Principle/","link":"","permalink":"https://yncbearz.github.io/2020/09/19/Example-Dad-Restaurant-Liskov-Substitution-Principle/","excerpt":"Example:Dad Restaurant (Liskov Substitution Principle)","text":"Principle: 裡氏替換原則 情境：老爸開了一間速食餐廳 首先定義餐廳的產出：餐點介面 12345678&lt;?phpnamespace App\\SOLID\\LSP\\Restaurant\\Contracts;interface Eatable&#123; public function beEaten();&#125; 接著供應的餐點類型：漢堡、炸雞、雞塊，它們都必須實作餐點介面 12345678910111213&lt;?phpnamespace App\\SOLID\\LSP\\Restaurant\\Food;use App\\SOLID\\LSP\\Restaurant\\Contracts\\Eatable;class Burger implements Eatable&#123; public function beEaten() &#123; return '招牌漢堡被吃了'; &#125;&#125; 12345678910111213&lt;?phpnamespace App\\SOLID\\LSP\\Restaurant\\Food;use App\\SOLID\\LSP\\Restaurant\\Contracts\\Eatable;class FriedChicken implements Eatable&#123; public function beEaten() &#123; return '招牌炸雞被吃了'; &#125;&#125; 12345678910111213&lt;?phpnamespace App\\SOLID\\LSP\\Restaurant\\Food;use App\\SOLID\\LSP\\Restaurant\\Contracts\\Eatable;class ChickenNuggets implements Eatable&#123; public function beEaten() &#123; return '招牌雞塊被吃了'; &#125;&#125; 最後是老爸的餐廳 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace App\\SOLID\\LSP\\Restaurant;use App\\SOLID\\LSP\\Restaurant\\Contracts\\Eatable;use App\\SOLID\\LSP\\Restaurant\\Food\\Burger;use Exception;use App\\SOLID\\LSP\\Restaurant\\Food\\ChickenNuggets;use App\\SOLID\\LSP\\Restaurant\\Food\\FriedChicken;class DadRestaurant&#123; public function getFood($money): Eatable &#123; if (!is_int($money)) &#123; throw new Exception('我們只收現金'); &#125; $randomNumber = rand(1, 3); switch ($randomNumber) &#123; case 1: return new Burger(); break; case 2: return new FriedChicken(); break; case 3: return new ChickenNuggets(); break; &#125; &#125;&#125; 這邊可以發現，老爸餐廳的出餐是很隨意的，客人用現金，可以換取餐點。 但餐點可能是漢堡、炸雞或是雞塊其中之一。 時光匆匆，過了幾年，兒子決定繼承老爸餐廳 現在有些客人會使用信用卡等其他的付款方式。也不希望餐廳餐點總是如此隨意，無法預料。 新開的餐廳決定只供應漢堡這種餐點，並提供其他付款方式。（即對Input型態更寬鬆，而Output型態更嚴謹） 兒子新開的餐廳 123456789101112131415&lt;?phpnamespace App\\SOLID\\LSP\\Restaurant;use App\\SOLID\\LSP\\Restaurant\\DadRestaurant;use App\\SOLID\\LSP\\Restaurant\\Food\\Burger;use App\\SOLID\\LSP\\Restaurant\\Contracts\\Eatable;class SonRestaurant extends DadRestaurant&#123; public function getFood($goldFlow): Eatable &#123; return new Burger(); &#125;&#125; 測試客人消費的情況 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpnamespace Tests\\Unit\\SOLID\\LSP;use PHPUnit\\Framework\\TestCase;use App\\SOLID\\LSP\\Restaurant\\Program;use App\\SOLID\\LSP\\Restaurant\\Contracts\\Eatable;class ProgramTest extends TestCase&#123; /** * @var Program */ protected $sut; public function setUp(): void &#123; $this-&gt;sut = new Program(); &#125; public function testUseMoneyInDadRestaurant() &#123; $expected = Eatable::class; $money = 100; $actual = $this-&gt;sut-&gt;getFoodInDadRestaurant($money); $this-&gt;assertInstanceOf($expected, $actual); &#125; public function testUseCardInDadRestaurant() &#123; $card = '信用卡'; $this-&gt;expectExceptionMessage('我們只收現金'); $this-&gt;sut-&gt;getFoodInDadRestaurant($card); &#125; public function testUseMoneyInSonRestaurant() &#123; $expected = Eatable::class; $money = 100; $actual = $this-&gt;sut-&gt;getFoodInSonRestaurant($money); $this-&gt;assertInstanceOf($expected, $actual); &#125; public function testUseCardInSonRestaurant() &#123; $expected = Eatable::class; $card = '信用卡'; $actual = $this-&gt;sut-&gt;getFoodInSonRestaurant($card); $this-&gt;assertInstanceOf($expected, $actual); &#125;&#125; 透過測試，我們可以發現： 顧客類型 付款方式 老爸的餐廳 兒子的餐廳 老顧客 現金 可以換取餐點 可以換取餐點 （但只有漢堡） 新顧客 信用卡 無法換取餐點 可以換取餐點 符合了裡氏替換原則的精神。 ʕ •ᴥ•ʔ：這是一個簡易的範例，細節部分請大家多多包涵。","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://yncbearz.github.io/categories/Clean-Code/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"類別圖：Line群組通知（觀察者模式）","slug":"Class-Diagram-Line-Group-Observer-Pattern","date":"2020-09-16T16:25:37.000Z","updated":"2020-09-20T15:49:51.263Z","comments":true,"path":"2020/09/17/Class-Diagram-Line-Group-Observer-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/09/17/Class-Diagram-Line-Group-Observer-Pattern/","excerpt":"Class Diagram:Line Group (Observer Pattern)","text":"Example: Line群組通知 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：Line群組通知（觀察者模式）","slug":"Example-Line-Group-Observer-Pattern","date":"2020-09-16T13:14:10.000Z","updated":"2020-10-11T16:47:14.081Z","comments":true,"path":"2020/09/16/Example-Line-Group-Observer-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/09/16/Example-Line-Group-Observer-Pattern/","excerpt":"Example:Line Group (Observer Pattern)","text":"Pattern: 觀察者模式 Class Diagram: Line群組通知 情境：讓我們用Line群組，來實作觀察者模式 首先實作抽象的觀察者類別 (Observer) 其中會有接收到主題類別通知時的更新方法 （具體實作內容由子類決定）。 12345678&lt;?phpnamespace App\\ObserverPattern\\LineGroup;abstract class Observer&#123; abstract public function update();&#125; 接著實作抽象的主題類別 (Subject) 它會有新增觀察者、移除觀察者、通知觀察者的方法。 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App\\ObserverPattern\\LineGroup;use App\\ObserverPattern\\LineGroup\\Observer;abstract class Subject&#123; /** * @var array */ protected $observers = []; public function attachObserver(Observer $observer) &#123; $this-&gt;observers[] = $observer; &#125; public function detachObserver(Observer $observer) &#123; $index = array_search($observer, $this-&gt;observers); if ($index &gt;= 0) &#123; unset($this-&gt;observers[$index]); &#125; &#125; public function notifyObservers() &#123; foreach ($this-&gt;observers as $observer) &#123; $observer-&gt;update(); &#125; &#125;&#125; 利用剛剛建立的觀察者類別，實作使用者 123456789101112131415161718192021&lt;?phpnamespace App\\ObserverPattern\\LineGroup;use App\\ObserverPattern\\LineGroup\\Observer;class User extends Observer&#123; protected $name; public function __construct($name) &#123; $this-&gt;name = $name; &#125; public function update() &#123; //使用者手機跳出通知 //使用者電腦跳出通知 &#125;&#125; 實作群組聊天室，並模擬使用情況 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace App\\ObserverPattern\\LineGroup;use App\\ObserverPattern\\LineGroup\\Subject;use App\\ObserverPattern\\LineGroup\\User;class Program extends Subject&#123; protected $state = 'nothing new'; public function run() &#123; //Bear加入群組 $bear = new User('Bear'); $this-&gt;attachObserver($bear); //通知群組 $this-&gt;notifyObservers(); //Jane加入群組 $jane = new User('Jane'); $this-&gt;attachObserver($jane); //通知群組 $this-&gt;notifyObservers(); //有新訊息，通知群組 $this-&gt;state = 'new message'; $this-&gt;notifyObservers(); $this-&gt;state = 'nothing new'; //Jane離開群組 $this-&gt;detachObserver($jane); //通知群組 $this-&gt;notifyObservers(); &#125;&#125; \b[單一職責原則]我們將主題類別 (Subject) 與觀察者類別 (Observer) 視作兩種不同的職責。目前範例尚未將聊天室的職責與通知的職責分離。 \b[開放封閉原則]當新增新的主題類別時，我們可以輕易地新增、移除、通知對應觀察者。亦可以新增新的觀察者類別，再將其加入既有的主題類別。 [裡氏替換原則]透過子類來定義觀察者類別中更新方法具體的實作。目前範例的缺點是，觀察者類別不好對更新方法取更適合的命名。 \b[依賴反轉原則]抽象主題類別依賴於抽象的觀察者類別。使用者類別實作抽象的觀察者類別。 主題類別不必知道具體觀察者想做什麼，僅需知道觀察者類別有接口可以通知更新。 ʕ •ᴥ•ʔ：架構容易，細節仍需琢磨的模式。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"觀察者模式","slug":"Observer-Pattern","date":"2020-09-13T14:43:12.000Z","updated":"2020-10-12T16:06:41.393Z","comments":true,"path":"2020/09/13/Observer-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/09/13/Observer-Pattern/","excerpt":"Observer Pattern","text":"Observer Pattern在對象之間定義一對多的依賴。當一個對象改變狀態，依賴它的對象都會收到通知，並自動更新。亦被稱作**發佈/訂閱模式 (Publish/Subscribe Pattern)**。Example: Line群組通知 觀察者模式會將類別分為兩類：分別是**主題類別 (Subject)與觀察者類別 (Observer)**。 透過增加/移除名單中的觀察者，來控制主題類別改變時，要通知的對象有哪些。 優點：透過定義好的主題介面與觀察者介面，將主題類別與觀察者類別的關係解耦。 即主題類別不需要知道真正的觀察者是誰，而觀察者類別也不需要知道到底是誰通知它的。 缺點：會使程式碼變得複雜。觀察者類別中的方法名稱必須一致（可以用事件委託技術修正）若觀察者訂閱多個主題時，無法決定被通知的順序。 與其他模式的比較：[命令模式]：命令模式中，調用者發送命令給接收者，由接收者決定是否執行命令。觀察者模式中，主題發送通知給觀察者後，由觀察者自行決定要執行的行動。 經常運用在實時事件系統。程式中有「通知」兩字的行為，很可能是它的應用時機。 ʕ •ᴥ•ʔ：又是個日常生活中就會看到的模式。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：運輸系統（抽象工廠模式）","slug":"Class-Diagram-Transport-Abstract-Factory-Pattern","date":"2020-09-08T13:01:23.000Z","updated":"2020-09-08T14:20:24.301Z","comments":true,"path":"2020/09/08/Class-Diagram-Transport-Abstract-Factory-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/09/08/Class-Diagram-Transport-Abstract-Factory-Pattern/","excerpt":"Class Diagram:Transport (Abstract Factory Pattern)","text":"Example: 運輸系統 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：運輸系統 （抽象工廠模式）","slug":"Example-Transport-Abstract-Factory-Pattern","date":"2020-09-04T13:21:08.000Z","updated":"2021-04-12T00:46:10.193Z","comments":true,"path":"2020/09/04/Example-Transport-Abstract-Factory-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/09/04/Example-Transport-Abstract-Factory-Pattern/","excerpt":"Example:Transport (Abstract Factory Pattern)","text":"Pattern: 抽象工廠模式 Class Diagram: 運輸系統 \b前情提要：鐵路運輸系統，參考範例：運輸系統（工廠方法模式） 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\\FactoryPattern\\Transport\\AbstractFactoryPattern;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\ModelFactory;use ReflectionClass;class Program&#123; /** * @param string $modelName * @return string */ public function getModel($modelName) &#123; $modelFactory = $this-&gt;createModelFactory($modelName); $model = $modelFactory-&gt;createModel(); return $model-&gt;getName(); &#125; /** * @param string $modelName * @return ModelFactory */ private function createModelFactory($modelName) &#123; $namespace = 'App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\ModelFactories'; $className = $modelName . 'Factory'; $reflector = new ReflectionClass($namespace . '\\\\' . $className); return $reflector-&gt;newInstance(); &#125;&#125; 需求一：各交通工具準備就緒，要開始處理內裝問題。 由於不同的機型會有不同的內裝，讓我們從定義椅子介面開始。 定義椅子介面 12345678&lt;?phpnamespace App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts;interface Chair&#123; public function getName();&#125; 接著改寫機型工廠介面，除了製作機型外，要新增製作椅子的方法。 12345678910111213&lt;?phpnamespace App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Model;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Chair;interface ModelFactory&#123; public function createModel(): Model; public function createChair(): Chair;&#125; 實作長型座椅 12345678910111213&lt;?phpnamespace App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Chair;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Chair;class LongChair implements Chair&#123; public function getName() &#123; return '長型座椅'; &#125;&#125; 實作對號座椅 12345678910111213&lt;?phpnamespace App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Chair;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Chair;class ReservedSeatChair implements Chair&#123; public function getName() &#123; return '對號座椅'; &#125;&#125; 實作飛機座椅 12345678910111213&lt;?phpnamespace App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Chair;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Chair;class PlaneChair implements Chair&#123; public function getName() &#123; return '飛機座椅'; &#125;&#125; 接著改寫各個機型工廠，選擇適合的座椅。 改寫區間車工廠 123456789101112131415161718192021222324&lt;?phpnamespace App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\ModelFactories;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Model;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\ModelFactory;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Model\\LocalTrain;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Chair;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Chair\\LongChair;class LocalTrainFactory implements ModelFactory&#123; public function createModel(): Model &#123; //取得生產材料... //招募技術團隊... return new LocalTrain(); &#125; public function createChair(): Chair &#123; return new LongChair(); &#125;&#125; 改寫復興號工廠 123456789101112131415161718192021222324&lt;?phpnamespace App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\ModelFactories;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Model;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\ModelFactory;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Model\\SemiExpress;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Chair;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Chair\\ReservedSeatChair;class SemiExpressFactory implements ModelFactory&#123; public function createModel(): Model &#123; //取得生產材料... //招募技術團隊... return new SemiExpress(); &#125; public function createChair(): Chair &#123; return new ReservedSeatChair(); &#125;&#125; 改寫自強號工廠 123456789101112131415161718192021222324&lt;?phpnamespace App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\ModelFactories;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Model;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Model\\LimitedExpress;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\ModelFactory;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Chair;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Chair\\ReservedSeatChair;class LimitedExpressFactory implements ModelFactory&#123; public function createModel(): Model &#123; //取得生產材料... //招募技術團隊... return new LimitedExpress(); &#125; public function createChair(): Chair &#123; return new ReservedSeatChair(); &#125;&#125; 改寫波音747工廠 123456789101112131415161718192021222324&lt;?phpnamespace App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\ModelFactories;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\ModelFactory;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Model;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Model\\Boeing747;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\Chair;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Chair\\PlaneChair;class Boeing747Factory implements ModelFactory&#123; public function createModel(): Model &#123; //取得生產材料... //招募技術團隊.. return new Boeing747(); &#125; public function createChair(): Chair &#123; return new PlaneChair(); &#125;&#125; 最後改寫原本的程式碼 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace App\\FactoryPattern\\Transport\\AbstractFactoryPattern;use App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\Contracts\\ModelFactory;use ReflectionClass;class Program&#123; /** * @param string $modelName * @return string */ public function getModel($modelName) &#123; $modelFactory = $this-&gt;createModelFactory($modelName); $model = $modelFactory-&gt;createModel(); return $model-&gt;getName(); &#125; /** * @param string $modelName * @return string */ public function getChair($modelName) &#123; $modelFactory = $this-&gt;createModelFactory($modelName); $chair = $modelFactory-&gt;createChair(); return $chair-&gt;getName(); &#125; /** * @param string $modelName * @return ModelFactory */ private function createModelFactory($modelName) &#123; $namespace = 'App\\FactoryPattern\\Transport\\AbstractFactoryPattern\\ModelFactories'; $className = $modelName . 'Factory'; $reflector = new ReflectionClass($namespace . '\\\\' . $className); return $reflector-&gt;newInstance(); &#125;&#125; 透過工廠介面，我們組合了各種類型產品。使得不同類型的產品之間，有了產品族的聯繫關係。 \b[單一職責原則]我們將工廠類別 (Creator) 與產品類別 (Product) 視作兩種不同的職責。 \b[開放封閉原則]當新增新的產品族時，我們僅需新增工廠類別。當修改既有產品時，我們僅需修改其產品類別，不會影響到其他的產品類別。 \b[介面隔離原則]工廠介面：用來創建機型及座椅。產品介面：用來創建對應的產品。 \b[依賴反轉原則]工廠介面依賴於抽象的機型介面與座椅介面。 工廠實作抽象的工廠介面。機型實作抽象的機型介面。座椅實作抽象的座椅介面。 ʕ •ᴥ•ʔ：雖然有點複雜，但這個模式好美。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"抽象工廠模式","slug":"Abstract-Factory-Pattern","date":"2020-09-04T13:16:26.000Z","updated":"2020-10-12T15:59:35.047Z","comments":true,"path":"2020/09/04/Abstract-Factory-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/09/04/Abstract-Factory-Pattern/","excerpt":"Abstract Factory Pattern","text":"Abstract Factory Pattern提供一個接口，用於創建相關或依賴對象的家族，而不需要明確指定具體類。即產品增加產品族的概念。Example: 運輸系統 抽象工廠模式會將類別分為兩類：分別是**工廠類別 (Creator)與產品類別 (Product)**。兩者皆有對應的抽象介面。 不同類型的產品結盟成產品族。 優點： 將創建物件的邏輯與物件本身的邏輯分離。 一個工廠只會對應一個產品族類別，遵守開放封閉原則。 缺點： 會使程式碼變得複雜。 不容易替產品族新增新的產品。（須修改抽象工廠介面） 與其他模式的比較：[簡單工廠模式]：簡單工廠模式\b僅擁有一個工廠，透過switch子句，創建同種類型的不同產品。 無法遵守開放封閉原則。 [工廠方法模式]： \b工廠方法模式擁有多個工廠，各個工廠創建同種類型的不同產品。 而抽象工廠模式則是擁有多個工廠，各個工廠創建多種類型的產品。不同類型的產品，有著一條隱密的線，形成產品族的關係。 ʕ •ᴥ•ʔ：把你學會的S.O.L.I.D同時發揮出來。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：運輸系統（工廠方法模式）","slug":"Class-Diagram-Transport-Factory-Method-Pattern","date":"2020-08-30T01:50:38.000Z","updated":"2020-10-04T04:28:06.842Z","comments":true,"path":"2020/08/30/Class-Diagram-Transport-Factory-Method-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/30/Class-Diagram-Transport-Factory-Method-Pattern/","excerpt":"Class Diagram:Transport (Factory Method Pattern)","text":"Example: 運輸系統 這個圖真的很適合說明依賴反轉原則 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：運輸系統（工廠方法模式）","slug":"Example-Transport-Factory-Method-Pattern","date":"2020-08-29T18:02:11.000Z","updated":"2021-04-12T00:44:09.254Z","comments":true,"path":"2020/08/30/Example-Transport-Factory-Method-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/30/Example-Transport-Factory-Method-Pattern/","excerpt":"Example:Transport (Factory Method Pattern)","text":"Pattern: 工廠方法模式 Class Diagram: 運輸系統 \b前情提要：鐵路運輸系統，參考範例：運輸系統（簡單工廠模式) 12345678910111213141516171819&lt;?phpnamespace App\\FactoryPattern\\Transport\\SimpleFactoryPattern;use App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\RailwayModelFactory;class Program&#123; /** * @param string $modelName * @return string */ public function getModel($modelName) &#123; $railwayModelFactory = new RailwayModelFactory(); $model = $railwayModelFactory-&gt;createModel($modelName); return $model-&gt;getName(); &#125;&#125; 需求一：隨著公司擴大，運輸系統不再僅限鐵路，將引進波音747，進軍航空業 此時發現，原本的簡單工廠，從創建對象都是火車，到有飛機，邏輯越來越複雜了。 常常違反開放封閉原則，讓我們用工廠方法模式修正它。 首先定義機型工廠介面（可生產火車、飛機等各種機型） 12345678910&lt;?phpnamespace App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Contracts;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Contracts\\Model;interface ModelFactory&#123; public function createModel(): Model;&#125; 實作區間車工廠 1234567891011121314151617&lt;?phpnamespace App\\FactoryPattern\\Transport\\FactoryMethodPattern\\ModelFactories;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Contracts\\Model;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Contracts\\ModelFactory;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Model\\LocalTrain;class LocalTrainFactory implements ModelFactory&#123; public function createModel(): Model &#123; //取得生產材料... //招募技術團隊... return new LocalTrain(); &#125;&#125; 實作復興號工廠 1234567891011121314151617&lt;?phpnamespace App\\FactoryPattern\\Transport\\FactoryMethodPattern\\ModelFactories;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Contracts\\Model;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Contracts\\ModelFactory;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Model\\SemiExpress;class SemiExpressFactory implements ModelFactory&#123; public function createModel(): Model &#123; //取得生產材料... //招募技術團隊... return new SemiExpress(); &#125;&#125; 實作自強號工廠 1234567891011121314151617&lt;?phpnamespace App\\FactoryPattern\\Transport\\FactoryMethodPattern\\ModelFactories;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Contracts\\Model;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Model\\LimitedExpress;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Contracts\\ModelFactory;class LimitedExpressFactory implements ModelFactory&#123; public function createModel(): Model &#123; //取得生產材料... //招募技術團隊... return new LimitedExpress(); &#125;&#125; 修改原本的程式碼 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpnamespace App\\FactoryPattern\\Transport\\FactoryMethodPattern;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\ModelFactories\\LimitedExpressFactory;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\ModelFactories\\LocalTrainFactory;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\ModelFactories\\SemiExpressFactory;class Program&#123; /** * @param string $modelName * @return string */ public function getModel($modelName) &#123; $modelFactory = $this-&gt;createModelFactory($modelName); $model = $modelFactory-&gt;createModel(); return $model-&gt;getName(); &#125; /** * @param string $modelName * @return ModelFactory */ private function createModelFactory($modelName) &#123; switch ($modelName) &#123; case 'LimitedExpress': return new LimitedExpressFactory(); break; case 'LocalTrain': return new LocalTrainFactory(); break; case 'SemiExpress': return new SemiExpressFactory(); break; &#125; &#125;&#125; 運用反射 (Reflection) 機制，讓客戶端的程式碼不再修改 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\\FactoryPattern\\Transport\\FactoryMethodPattern;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Contracts\\ModelFactory;use ReflectionClass;class Program&#123; /** * @param string $modelName * @return string */ public function getModel($modelName) &#123; $modelFactory = $this-&gt;createModelFactory($modelName); $model = $modelFactory-&gt;createModel(); return $model-&gt;getName(); &#125; /** * @param string $modelName * @return ModelFactory */ private function createModelFactory($modelName) &#123; $namespace = 'App\\FactoryPattern\\Transport\\FactoryMethodPattern\\ModelFactories'; $className = $modelName . 'Factory'; $reflector = new ReflectionClass($namespace . '\\\\' . $className); return $reflector-&gt;newInstance(); &#125;&#125; 這下子，改造工程結束，讓我們回到波音747！ 實作波音747機型 12345678910111213&lt;?phpnamespace App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Model;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Contracts\\Model;class Boeing747 implements Model&#123; public function getName() &#123; return '波音747'; &#125;&#125; 最後實作波音747工廠 123456789101112131415&lt;?phpnamespace App\\FactoryPattern\\Transport\\FactoryMethodPattern\\ModelFactories;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Contracts\\ModelFactory;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Contracts\\Model;use App\\FactoryPattern\\Transport\\FactoryMethodPattern\\Model\\Boeing747;class Boeing747Factory implements ModelFactory&#123; public function createModel(): Model &#123; return new Boeing747(); &#125;&#125; \b[單一職責原則]我們將**創建類別 (Creator)與產品類別 (Product)**視作兩種不同的職責。 \b[開放封閉原則]當新增新的產品時，我們僅需新增產品類別及新增創建類別。當修改既有產品時，我們僅需修改其產品類別，不會影響到其他的產品類別。 \b[介面隔離原則]拆分出工廠介面與機型介面。 \b[依賴反轉原則]客戶依賴於抽象工廠介面與機型介面。工廠類別實作抽象的工廠介面。機型類別實作抽象的機型介面。 ʕ •ᴥ•ʔ：不久之後，我們會再一次看到這個範例，敬請期待。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"工廠方法模式","slug":"Factory-Method-Pattern","date":"2020-08-29T18:01:01.000Z","updated":"2020-10-17T08:21:31.801Z","comments":true,"path":"2020/08/30/Factory-Method-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/30/Factory-Method-Pattern/","excerpt":"Factory Method Pattern","text":"Factory Method Pattern簡單工廠的延伸，不再提供統一的工廠類來建立所有物件，而是將Factory類別抽象化，針對不同分類的物件有不同的工廠。Example: 運輸系統 工廠方法模式會將類別分為兩類：分別是工廠類別 (Creator) 與 產品類別 (Product) 。 透過定義好的介面，讓類別的實例化延遲到子類中進行。 優點：將創建物件的邏輯與物件本身的邏輯分離。一個工廠只會對應一個類別，完全遵守了開放封閉原則。 缺點：會做出很多小類別。（每次新增產品類別，就得新增對應的工廠類別） 與其他模式的比較：[簡單工廠模式]： \b比起簡單工廠模式，工廠方法模式能在創建物件時，將複雜的創建邏輯處理地更好。 [樣板方法模式]：工廠方法模式，是一個迷你的樣板方法模式，它只提出了建造類別這個步驟。 ʕ •ᴥ•ʔ：將開放封閉原則展現的淋漓盡致！","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：運輸系統（簡單工廠模式）","slug":"Class-Diagram-Transport-Simple-Factory-Pattern","date":"2020-08-29T18:00:15.000Z","updated":"2020-09-24T14:06:10.193Z","comments":true,"path":"2020/08/30/Class-Diagram-Transport-Simple-Factory-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/30/Class-Diagram-Transport-Simple-Factory-Pattern/","excerpt":"Class Diagram:Transport (Simple Factory nattern)","text":"Example: 運輸系統 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：運輸系統（簡單工廠模式)","slug":"Example-Transport-Simple-Factory-Pattern","date":"2020-08-29T16:19:25.000Z","updated":"2021-04-12T00:41:26.836Z","comments":true,"path":"2020/08/30/Example-Transport-Simple-Factory-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/30/Example-Transport-Simple-Factory-Pattern/","excerpt":"Example:Transport (Simple Factory Pattern)","text":"Pattern: 簡單工廠模式 Class Diagram: 運輸系統 \b情境：運輸系統，用來取得當前機型名稱等資訊 1234567891011121314151617181920212223&lt;?phpnamespace App\\FactoryPattern\\Transport\\SimpleFactoryPattern;class Program&#123; /** * @param string $modelName * @return string */ public function getModel($modelName) &#123; switch ($modelName) &#123; case 'LocalTrain': return '區間車'; break; case 'LimitedExpress': return '自強號'; break; &#125; &#125;&#125; 需求一：新增復興號 (SemiExpress) 正當我們想直接在switch中新增一個case時，發現這種做法違反了開放封閉原則。 明明是新增機型，卻修改到了既有的程式碼（取得機型名稱）。此外在修改機型名稱時，也會修改到既有程式碼。 讓我們用簡單工廠模式，將創建物件與物件本身的職責分離。（註：客戶端的程式碼、創建機型、機型本身，共三種職責） 首先定義機型介面 12345678&lt;?phpnamespace App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Contracts;interface Model&#123; public function getName();&#125; 實作區間車機型 12345678910111213&lt;?phpnamespace App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Model;use App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Contracts\\Model;class LocalTrain implements Model&#123; public function getName() &#123; return '區間車'; &#125;&#125; 實作自強號機型 12345678910111213&lt;?phpnamespace App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Model;use App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Contracts\\Model;class LimitedExpress implements Model&#123; public function getName() &#123; return '自強號'; &#125;&#125; 實作鐵路機型工廠 123456789101112131415161718192021222324252627&lt;?phpnamespace App\\FactoryPattern\\Transport\\SimpleFactoryPattern;use App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Contracts\\Model;use App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Model\\LocalTrain;use App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Model\\LimitedExpress;class RailWayModelFactory&#123; /** * @param string $modelName * @return Model */ public function createModel($modelName): Model &#123; switch ($modelName) &#123; case 'LocalTrain': return new LocalTrain(); break; case 'LimitedExpress': return new LimitedExpress(); break; &#125; &#125;&#125; 接著是修改原本的程式 12345678910111213141516171819&lt;?phpnamespace App\\FactoryPattern\\Transport\\SimpleFactoryPattern;use App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\RailwayModelFactory;class Program&#123; /** * @param string $modelName * @return string */ public function getModel($modelName) &#123; $railwayModelFactory = new RailwayModelFactory(); $model = $railwayModelFactory-&gt;createModel($modelName); return $model-&gt;getName(); &#125;&#125; 回到需求，實作復興號機型 12345678910111213&lt;?phpnamespace App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Model;use App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Contracts\\Model;class SemiExpress implements Model&#123; public function getName() &#123; return '復興號'; &#125;&#125; 最後修改鐵路機型工廠 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\\FactoryPattern\\Transport\\SimpleFactoryPattern;use App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Contracts\\Model;use App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Model\\LocalTrain;use App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Model\\LimitedExpress;use App\\FactoryPattern\\Transport\\SimpleFactoryPattern\\Model\\SemiExpress;class RailWayModelFactory&#123; /** * @param string $model * @return Model */ public function createModel($model): Model &#123; switch ($model) &#123; case 'LocalTrain': return new LocalTrain(); break; case 'LimitedExpress': return new LimitedExpress(); break; case 'SemiExpress': return new SemiExpress(); break; &#125; &#125;&#125; \b[單一職責原則] 我們將**創建類別 (Creator)與產品類別 (Product)**視作兩種不同的職責。 將取得機型資訊的運輸系統視作第三種職責。 \b[開放封閉原則] 當新增新的產品時，我們僅需新增產品類別及修改創建類別。 當修改既有產品時，我們僅需修改其產品類別及創建類別，不會影響到其他的產品類別。 無論是新增/修改產品，我們都不用再去修改到運輸系統類別。 [依賴反轉原則] 運輸類別依賴抽象的機型介面。 產品類別實作抽象的機型介面。 透過簡單工廠模式，運輸系統類別減少了改變的機會，但創建類別依然常常需要變更。 ʕ •ᴥ•ʔ：不久之後，我們還會見到這個範例，敬請期待。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"類別圖：會員制 （狀態模式）","slug":"Class-Diagram-Premium-State-Pattern","date":"2020-08-25T00:55:57.000Z","updated":"2020-10-10T08:16:22.116Z","comments":true,"path":"2020/08/25/Class-Diagram-Premium-State-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/25/Class-Diagram-Premium-State-Pattern/","excerpt":"Class Diagram:Premium (State Pattern)","text":"Example: 會員制 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：會員制（狀態模式）","slug":"Example-Premium-State-Pattern","date":"2020-08-20T17:08:01.000Z","updated":"2020-10-10T08:12:07.354Z","comments":true,"path":"2020/08/21/Example-Premium-State-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/21/Example-Premium-State-Pattern/","excerpt":"Example:Premium (State Pattern)","text":"Pattern: 狀態模式 Class Diagram: 會員制 情境：平台有三種身份，分別是訪客 (guest)、會員 (member)及付費會員(premium) 訪客藉由**註冊 (register)**，可成為會員。 會員藉由**訂閱 (subsribe)**，可成為付費會員。 付費會員藉由**取消訂閱 (cancelSubscription)**，可變回會員。 會員及付費會員藉由**刪除帳號 (deleteAccount)**，可變回訪客。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?phpnamespace App\\StatePattern\\Youtube;use Exception;class Program&#123; /** * @var string */ protected $license; public function __construct() &#123; $this-&gt;setLicense('guest'); &#125; public function register() &#123; if ($this-&gt;license == 'premium') &#123; return; &#125; $this-&gt;license = 'member'; &#125; public function getLicense() &#123; return $this-&gt;license; &#125; /** * @param string $license */ public function setLicense($license) &#123; $this-&gt;license = $license; &#125; public function subscribe() &#123; if ($this-&gt;license == 'premium') &#123; return; &#125; if ($this-&gt;license == 'member') &#123; $this-&gt;license = 'premium'; return; &#125; throw new Exception('You need to be a member before subscribing.'); &#125; public function cancelSubscription() &#123; if ($this-&gt;license == 'premium') &#123; $this-&gt;license = 'member'; return; &#125; throw new Exception('Sorry, you have not subscribed.'); &#125; public function deleteAccount() &#123; if ($this-&gt;license == 'member' || $this-&gt;license == 'premium') &#123; $this-&gt;license = 'guest'; return; &#125; throw new Exception('You need to be a member before deleting account.'); &#125;&#125; 隨著功能越來越多，每次新增功能時，我們都會有許多複雜的條件式（判斷當前用戶狀態）。 讓我們用狀態模式改善它。 需求一：切分出不同的用戶狀態 首先定義用戶狀態（抽象） 123456789101112131415161718192021&lt;?phpnamespace App\\StatePattern\\Youtube\\State;abstract class UserState&#123; const LICENCE = 'undefined user'; public function getLicense() &#123; return $this::LICENCE; &#125; abstract function register(); abstract function subscribe(); abstract function cancelSubscription(); abstract function deleteAccount();&#125; 訪客狀態 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpnamespace App\\StatePattern\\Youtube\\State;use App\\StatePattern\\Youtube\\Program;use Exception;use App\\StatePattern\\Youtube\\State\\UserState;class GuestState extends UserState&#123; /** * @var Program */ protected $program; /** * @var string */ const LICENCE = 'guest'; /** * @param Program $program */ public function __construct(Program $program) &#123; $this-&gt;program = $program; &#125; public function register() &#123; $this-&gt;program-&gt;setMemberState(); &#125; public function subscribe() &#123; throw new Exception('You need to be a member before subscribing.'); &#125; public function cancelSubscription() &#123; throw new Exception('Sorry, you have not subscribed.'); &#125; public function deleteAccount() &#123; throw new Exception('You need to be a member before deleting account.'); &#125;&#125; 會員狀態 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpnamespace App\\StatePattern\\Youtube\\State;use App\\StatePattern\\Youtube\\Program;use Exception;use App\\StatePattern\\Youtube\\State\\UserState;class MemberState extends UserState&#123; /** * @var Program */ protected $program; /** * @var string */ const LICENCE = 'member'; /** * @param Program $program */ public function __construct(Program $program) &#123; $this-&gt;program = $program; &#125; public function register() &#123; return; &#125; public function subscribe() &#123; $this-&gt;program-&gt;setPremiumState(); &#125; public function cancelSubscription() &#123; throw new Exception('Sorry, you have not subscribed.'); &#125; public function deleteAccount() &#123; $this-&gt;program-&gt;setGuestState(); &#125;&#125; 付費會員狀態 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace App\\StatePattern\\Youtube\\State;use App\\StatePattern\\Youtube\\Program;use App\\StatePattern\\Youtube\\State\\UserState;class PremiumState extends UserState&#123; /** * @var Program */ protected $program; /** * @var string */ const LICENCE = 'premium'; /** * @param Program $program */ public function __construct(Program $program) &#123; $this-&gt;program = $program; &#125; public function register() &#123; return; &#125; public function subscribe() &#123; return; &#125; public function cancelSubscription() &#123; $this-&gt;program-&gt;setMemberState(); &#125; public function deleteAccount() &#123; $this-&gt;program-&gt;setGuestState(); &#125;&#125; 最後修改原本的情境類別 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?phpnamespace App\\StatePattern\\Youtube;use App\\StatePattern\\Youtube\\State\\MemberState;use App\\StatePattern\\Youtube\\State\\GuestState;use App\\StatePattern\\Youtube\\State\\PremiumState;use App\\StatePattern\\Youtube\\State\\UserState;class Program&#123; /** * @var string */ protected $license; /** * @var MemberState */ protected $memberState; /** * @var GuestState */ protected $guestState; /** * @var PremiumState */ protected $premiumState; /** * @var UserState */ protected $state; public function __construct() &#123; $this-&gt;memberState = new MemberState($this); $this-&gt;guestState = new GuestState($this); $this-&gt;premiumState = new PremiumState($this); $this-&gt;setGuestState(); &#125; public function register() &#123; $this-&gt;state-&gt;register(); &#125; public function getLicense() &#123; return $this-&gt;state-&gt;getLicense(); &#125; public function subscribe() &#123; $this-&gt;state-&gt;subscribe(); &#125; public function cancelSubscription() &#123; $this-&gt;state-&gt;cancelSubscription(); &#125; public function setGuestState() &#123; $this-&gt;state = $this-&gt;guestState; &#125; public function setMemberState() &#123; $this-&gt;state = $this-&gt;memberState; &#125; public function setPremiumState() &#123; $this-&gt;state = $this-&gt;premiumState; &#125; public function getState() &#123; return $this-&gt;state; &#125; public function deleteAccount() &#123; $this-&gt;state-&gt;deleteAccount(); &#125;&#125; \b[單一職責原則]我們將情境類別與狀態類別視作兩種不同的職責。透過委派來實現不同狀態下的行為。 \b[開放封閉原則]修改既有狀態類別的行為，不會影響到全部的既有狀態類別。（新增狀態類別時，可能會影響到） [介面隔離原則]情境類別依賴於抽象的用戶狀態 (User State)。不同的狀態類別實作抽象的**用戶狀態 (User State)**。 ʕ •ᴥ•ʔ：透過測試，重構這個範例時有遇到一些小困難。大家也可以挑戰看看。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"狀態模式","slug":"State-Pattern","date":"2020-08-20T17:07:23.000Z","updated":"2020-12-20T11:28:20.679Z","comments":true,"path":"2020/08/21/State-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/21/State-Pattern/","excerpt":"State Pattern","text":"State Pattern允許對象在內部狀態改變時，改變它的行為，對象看起來好像修改了它的類。Example: 會員制 狀態模式會將類別分為兩類：分別是**情境類別 (Context)**與 **狀態類別 (State)**。 當前對象會隨著內部狀態，改變它的行為。 狀態模式涉及了有限狀態機 (Finite-State Machine)的概念。\b有限個狀態，彼此間因動作而造成狀態轉移的系統，同一時間內只會表現出一種狀態。 優點：將狀態類抽離，可讓當前對象複雜的條件判斷簡化。即消除龐大的條件分支敘述。 缺點：會製造出許多的小類別。 與其他模式的比較：[簡單工廠模式]：簡單工廠模式的物件，創造後行為就不會改變了。而狀態模式則可能因應其狀態，做出不同的行為。 [策略模式]：定義算法族，委派給不同的物件。而狀態模式中的小類別層級，皆可獨立運作。 ʕ •ᴥ•ʔ：狀態模式有點像是簡單工廠模式 + 策略模式的結合應用。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：自助餐餐廳（外觀模式）","slug":"Class-Diagram-Buffet-Facade-Pattern","date":"2020-08-16T15:22:42.000Z","updated":"2020-10-07T16:39:46.323Z","comments":true,"path":"2020/08/16/Class-Diagram-Buffet-Facade-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/16/Class-Diagram-Buffet-Facade-Pattern/","excerpt":"Class Diagram:Buffet (Facade Pattern)","text":"Example: 自助餐餐廳 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：自助餐餐廳 （外觀模式)","slug":"Example-Buffet-Facade-Pattern","date":"2020-08-15T16:43:53.000Z","updated":"2020-10-06T16:01:15.621Z","comments":true,"path":"2020/08/16/Example-Buffet-Facade-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/16/Example-Buffet-Facade-Pattern/","excerpt":"Example:Buffet (Facade Pattern)","text":"Pattern: 外觀模式 Class Diagram: 自助餐餐廳 情境：以下是某自助餐餐廳的情況 自助式霜淇淋機 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\FacadePattern\\Buffet;class IceCreamMachine&#123; public function addIngredients() &#123; //倒入牛奶、糖、鮮奶油、蛋黃等 return $this; &#125; public function stir() &#123; //攪拌均勻 return $this; &#125; public function chill() &#123; //使其冷藏 return $this; &#125; public function squeeze() &#123; //擠出霜淇淋 return '霜淇淋'; &#125;&#125; 自助式咖啡機 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\FacadePattern\\Buffet;class CoffeeMachine&#123; public function addCoffeeBeans() &#123; //放入咖啡豆 return $this; &#125; public function grind() &#123; //研磨咖啡豆 return $this; &#125; public function brew() &#123; //沖煮咖啡 return $this; &#125; public function stirWithMilk() &#123; //與牛奶攪拌 return '拿鐵'; &#125;&#125; 老闆認為目前的方式，客人必須知道霜淇淋機與咖啡機所有的操作流程。 不是那麼地友好，希望我們能寫個簡單的介面，讓客人更容易取得餐點。 需求一：替霜淇淋機與咖啡機設計簡單的介面，方便取用 霜淇淋機的簡單介面 12345678910111213141516171819&lt;?phpnamespace App\\FacadePattern\\Buffet\\Facade;use App\\FacadePattern\\Buffet\\IceCreamMachine;class IceCreamMachineFacade&#123; public static function makeIceCream() &#123; $iceCreamMachine = new IceCreamMachine(); return $iceCreamMachine -&gt;addIngredients() -&gt;stir() -&gt;chill() -&gt;squeeze(); &#125;&#125; 咖啡機的簡單介面 12345678910111213141516171819&lt;?phpnamespace App\\FacadePattern\\Buffet\\Facade;use App\\FacadePattern\\Buffet\\CoffeeMachine;class CoffeeMachineFacade&#123; public static function makeLatte() &#123; $coffeeMachine = new CoffeeMachine(); return $coffeeMachine -&gt;addCoffeeBeans() -&gt;grind() -&gt;brew() -&gt;stirWithMilk(); &#125;&#125; 最後修改客人的點餐程式 12345678910111213141516171819&lt;?phpnamespace App\\FacadePattern\\Buffet;use App\\FacadePattern\\Buffet\\Facade\\CoffeeMachineFacade;use App\\FacadePattern\\Buffet\\Facade\\IceCreamMachineFacade;class Program&#123; public function makeIceCream() &#123; return IceCreamMachineFacade::makeIceCream(); &#125; public function makeLatte() &#123; return CoffeeMachineFacade::makeLatte(); &#125;&#125; 這下子，客人終於不用知道太多，便能取得自己想要的餐點了。 \b[單一職責原則]我們將子類別與接口類別視作兩種不同的職責。 \b[開放封閉原則]對於客戶端與接口類別來說，並不會因為我們用了新的咖啡機而有所區別。 然而當子類別改動時可能會連帶修改到接口類別。 ʕ •ᴥ•ʔ：在這個例子中，我會覺得是霜淇淋機/咖啡機不對，竟然沒有提供簡單的介面！","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"外觀模式","slug":"Facade-Pattern","date":"2020-08-15T16:41:49.000Z","updated":"2020-10-06T16:32:28.333Z","comments":true,"path":"2020/08/16/Facade-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/16/Facade-Pattern/","excerpt":"Facade Pattern","text":"Facade Pattern提供一個統一的接口，用來訪問子系統中的一群接口。外觀模式定義了一個高層接口，讓子系統更容易使用。Example: 自助餐餐廳 外觀模式會將類別分為兩類：分別是統一的接口類 (Facade) 與**子系統類 (Subsystem)**。 接口類會提供簡單的接口，供客戶使用。 優點：因為封裝，解除了客戶與子系統間的耦合關係。可以透過接口類，來操作子系統中複雜的功能。 缺點：接口類可能會因為耦合太多子系統，而職責過重。 與其他模式的比較：[轉接頭模式]：轉接頭模式將一個接口轉化成另一個接口。而外觀模式則是提供簡化接口。 兩者的差異不在於包裝了幾個類別，而是在於意圖的不同。 [樣板方法模式]：樣板方法模式的抽象規則類與實體算法類會實現相同接口。外觀模式則無此限制。 ʕ •ᴥ•ʔ：外觀模式是封裝的一種高級應用。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：才藝表演（轉接頭模式）","slug":"Class-Diagram-Talent-Show-Adapter-Pattern","date":"2020-08-10T00:38:26.000Z","updated":"2020-10-04T13:56:06.301Z","comments":true,"path":"2020/08/10/Class-Diagram-Talent-Show-Adapter-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/10/Class-Diagram-Talent-Show-Adapter-Pattern/","excerpt":"Class Diagram:Talent Show (Adapter Pattern)","text":"Example: 才藝表演 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：才藝表演（轉接頭模式）","slug":"Example-Talent-Show-Adapter-Pattern","date":"2020-08-09T07:34:23.000Z","updated":"2020-10-03T07:44:57.492Z","comments":true,"path":"2020/08/09/Example-Talent-Show-Adapter-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/09/Example-Talent-Show-Adapter-Pattern/","excerpt":"Example:Talent Show (Adapter Pattern)","text":"Pattern: 轉接頭模式 Class Diagram: 才藝表演 情境：以下是某才藝表演 12345678910111213141516171819202122&lt;?phpnamespace App\\AdapterPattern\\TalentShow;class Program&#123; /** * @return array */ public function run() &#123; $result = []; $pianoPlayer = new PianoPlayer(); $result[] = $pianoPlayer-&gt;play(); $jokeTeller = new JokeTeller(); $result[] = $jokeTeller-&gt;tell(); return $result; &#125;&#125; 主持人覺得需要知道，每位表演者的表演方式，有些麻煩。希望我們定義一個統一的介面，讓他的主持工作能更順利。 需求一：定義表演介面，使得表演項目能夠被管理 隨著項目變多，每個人的表演都不一樣。可能會有彈鋼琴、拉扯鈴、講笑話、演話劇等。 但是這些項目，未必都是為了才藝表演而存在。讓我們以此為基礎，切分兩者的職責。 首先定義表演的介面 12345678&lt;?phpnamespace App\\AdapterPattern\\TalentShow\\Contracts;interface ShowInterface&#123; public function show();&#125; 接著實作鋼琴表演者的轉接頭 123456789101112131415161718192021222324&lt;?phpnamespace App\\AdapterPattern\\TalentShow\\Adapter;use App\\AdapterPattern\\TalentShow\\PianoPlayer;use App\\AdapterPattern\\TalentShow\\Contracts\\ShowInterface;class PianoPlayerAdapter implements ShowInterface&#123; /** * @var PianoPlayer */ protected $pianoPlayer; public function __construct(PianoPlayer $pianoPlayer) &#123; $this-&gt;pianoPlayer = $pianoPlayer; &#125; public function show() &#123; return $this-&gt;pianoPlayer-&gt;play(); &#125;&#125; 透過這個轉接頭，當我們請鋼琴表演者表演時，他就會開始彈鋼琴。 再來是笑話表演者的轉接頭 123456789101112131415161718192021222324&lt;?phpnamespace App\\AdapterPattern\\TalentShow\\Adapter;use App\\AdapterPattern\\TalentShow\\Contracts\\ShowInterface;use App\\AdapterPattern\\TalentShow\\JokeTeller;class JokeTellerAdapter implements ShowInterface&#123; /** * @var JokeTeller */ protected $jokeTeller; public function __construct(JokeTeller $jokeTeller) &#123; $this-&gt;jokeTeller = $jokeTeller; &#125; public function show() &#123; return $this-&gt;jokeTeller-&gt;tell(); &#125;&#125; 透過這個轉接頭，當我們請笑話表演者表演時，他就會開始講笑話。 最後是修改原本的程式 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace App\\AdapterPattern\\TalentShow;use App\\AdapterPattern\\TalentShow\\Adapter\\PianoPlayerAdapter;use App\\AdapterPattern\\TalentShow\\Adapter\\JokeTellerAdapter;use App\\AdapterPattern\\TalentShow\\Contracts\\ShowInterface;class Program&#123; /** * @var ShowInterface[] */ protected $performers = []; /** * @return array */ public function run() &#123; $this-&gt;preparePerformers(); $result = []; foreach ($this-&gt;performers as $performer) &#123; $result[] = $performer-&gt;show(); &#125; return $result; &#125; private function preparePerformers() &#123; $pianoPlayer = new PianoPlayer(); $this-&gt;performers[] = new PianoPlayerAdapter($pianoPlayer); $jokeTeller = new JokeTeller(); $this-&gt;performers[] = new JokeTellerAdapter($jokeTeller); &#125;&#125; 透過各種實作表演介面的轉接頭，我們便能更好地管理表演項目了。（比如：進退場的流程、項目的介紹等） \b[單一職責原則]我們將才藝類別與表演項目類別視作兩種不同的職責。 \b[開放封閉原則]若我們需要在表演時，增加新的表演者，可以不修改原本才藝類別的程式碼。只需新增一個對應的轉接頭。 [介面隔離原則]才藝類別與表演項目類別實作的是兩個不同的接口。透過轉接頭，讓原本接口不同的類別能夠介接。 [依賴反轉原則]客戶端的程式碼依賴抽象的表演介面。轉接頭實作抽象的表演介面。 ʕ •ᴥ•ʔ：除了上述包裹類別的方式外，轉接頭還能透過多重繼承的方式實現。將來撰寫其他語言範例時，再來補充。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"轉接頭模式","slug":"Adapter-Pattern","date":"2020-08-09T07:31:09.000Z","updated":"2020-11-18T14:37:35.868Z","comments":true,"path":"2020/08/09/Adapter-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/09/Adapter-Pattern/","excerpt":"Adapter Pattern","text":"Adapter Pattern將一個類的接口，轉換成客戶期望的另一個接口。轉接頭讓原本接口不兼容的類可以合作無間。Example: 才藝表演 轉接頭模式會將類別分為三類：分別是原有的系統、轉接頭 (Adapter) 與客戶類別。 透過轉接頭類別，讓原有的系統能夠實現客戶類別所需的方法。 優點：可以在不改變原有的程式碼的情況下，製作轉接頭，使其與新的程式碼介接。 缺點：程式碼複雜度提高。 與其他模式的比較：[裝飾者模式]：裝飾者模式透過遞迴的方式，不停地豐富既有行為。而轉接頭模式則是透過改變介面來滿足新的程式碼。 [策略模式]：策略模式是定義出算法族，供不同類別去實作。而轉接頭模式是結合不同介面的算法，讓它們能實現相同的新介面。 ʕ •ᴥ•ʔ：比較常見的翻譯，好像是適配器或轉接器，不過我習慣叫它轉接頭模式。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"最小知識原則","slug":"Least-Knowledge-Principle","date":"2020-08-05T15:27:54.000Z","updated":"2020-08-04T16:26:28.978Z","comments":true,"path":"2020/08/05/Least-Knowledge-Principle/","link":"","permalink":"https://yncbearz.github.io/2020/08/05/Least-Knowledge-Principle/","excerpt":"Least Knowledge Principle (LKP)","text":"Least Knowledge PrincipleOnly talk to your immediate friends. 只跟你的密友說話。 客戶不該知道細節，僅需知道接口方法。 客戶不該知道內部生產的演算法、依賴了哪些類別，只需知道接口方法和結果。 其核心精神強調了類別之間的鬆耦合。（隱藏內部的實作，就更容易對其作出改變） 此原則亦被稱作**迪米特法則 (Law of Demeter)**。 ʕ •ᴥ•ʔ：除了類別間的關係，也可以應用在 API 的設計。","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://yncbearz.github.io/categories/Clean-Code/"}],"tags":[{"name":"Principle","slug":"Principle","permalink":"https://yncbearz.github.io/tags/Principle/"}]},{"title":"類別圖：影片製作大師（樣板方法模式）","slug":"Class-Diagram-Video-Maker-Template-Method-Pattern","date":"2020-08-03T14:24:05.000Z","updated":"2020-08-10T15:22:44.205Z","comments":true,"path":"2020/08/03/Class-Diagram-Video-Maker-Template-Method-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/03/Class-Diagram-Video-Maker-Template-Method-Pattern/","excerpt":"Class Diagram:Video Maker (Template Method Pattern)","text":"Example: 影片製作大師 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：影片製作大師（樣板方法模式）","slug":"Example-Video-Maker-Template-Method-Pattern","date":"2020-08-02T15:44:20.000Z","updated":"2020-10-03T07:47:00.098Z","comments":true,"path":"2020/08/02/Example-Video-Maker-Template-Method-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/02/Example-Video-Maker-Template-Method-Pattern/","excerpt":"Example:Video Maker (Template Method Pattern)","text":"Pattern: 樣板方法模式 Class Diagram: 影片製作大師 情境：以下是某攝影棚的影片製作方式 1234567891011121314151617181920212223&lt;?phpnamespace App\\TemplateMethodPattern\\Video;use App\\TemplateMethodPattern\\Video\\UnboxVideo;class Program&#123; public function makeUnboxVideo() &#123; return '選擇開箱項目、拍攝、剪輯出個人開箱的風格、上傳影片'; &#125; public function makeTutorialVideo() &#123; return '設計教學內容、拍攝、剪輯出個人教學的風格、上傳影片'; &#125; public function makeStoryVideo() &#123; return '選擇故事主題、拍攝、剪輯出個人說故事的風格、上傳影片'; &#125;&#125; 老闆覺得影片製作，有些相同的環節，希望我們開發程式解決，增加影片產生效率。 需求一：找出共同點，寫出樣板供大家使用 研究後發現，無論是哪種類型的影片，製作上大致可以歸類出四個步驟： 主題發想 影片拍攝 剪輯 上傳 由於公司影片大多於攝影棚拍攝，且上傳的平台相同，各個類型影片的差異，主要是在主題發想與剪輯。 我們以此為基礎，設計出樣板12345678910111213141516171819202122232425262728&lt;?phpnamespace App\\TemplateMethodPattern\\Video;abstract class BasicVideo&#123; public function make() &#123; return $this-&gt;generateIdeas() . '、' . $this-&gt;shoot() . '、' . $this-&gt;editing() . '、' . $this-&gt;upload(); &#125; protected function shoot() &#123; return '拍攝'; &#125; protected function upload() &#123; return '上傳影片'; &#125; abstract protected function generateIdeas(); abstract protected function editing();&#125; 在make()方法中，我們定義了一個影片產生的流程。 而拍攝與上傳是每種類型影片的共同行為，我們定義在shoot()方法及upload()方法中。 需求二：替各種類型的影片不同的部分作客製化 首先是開箱型影片 123456789101112131415161718&lt;?phpnamespace App\\TemplateMethodPattern\\Video;use App\\TemplateMethodPattern\\Video\\BasicVideo;class UnboxVideo extends BasicVideo&#123; protected function generateIdeas() &#123; return '選擇開箱項目'; &#125; protected function editing() &#123; return '剪輯出個人開箱的風格'; &#125;&#125; 接著是教學型影片 123456789101112131415161718&lt;?phpnamespace App\\TemplateMethodPattern\\Video;use App\\TemplateMethodPattern\\Video\\BasicVideo;class TutorialVideo extends BasicVideo&#123; protected function generateIdeas() &#123; return '設計教學內容'; &#125; protected function editing() &#123; return '剪輯出個人教學的風格'; &#125;&#125; 再來是故事型影片 123456789101112131415161718&lt;?phpnamespace App\\TemplateMethodPattern\\Video;use App\\TemplateMethodPattern\\Video\\BasicVideo;class StoryVideo extends BasicVideo&#123; protected function generateIdeas() &#123; return '選擇故事主題'; &#125; protected function editing() &#123; return '剪輯出個人說故事的風格'; &#125;&#125; 最後修改原本的程式 1234567891011121314151617181920212223242526&lt;?phpnamespace App\\TemplateMethodPattern\\Video;use App\\TemplateMethodPattern\\Video\\UnboxVideo;class Program&#123; public function makeUnboxVideo() &#123; $unboxVideo = new UnboxVideo(); return $unboxVideo-&gt;make(); &#125; public function makeTutorialVideo() &#123; $tutorialVideo = new TutorialVideo(); return $tutorialVideo-&gt;make(); &#125; public function makeStoryVideo() &#123; $storyVideo = new StoryVideo(); return $storyVideo-&gt;make(); &#125;&#125; \b[單一職責原則]我們將製作影片的流程與製作影片的方式視作兩種不同的職責。 \b[開放封閉原則]除了流程之外，不同影片的類型也歸類到不同的子類，未來新增/修改影片類型製作方式時，也不會互相影響。 [依賴反轉原則]客戶端的程式碼依賴抽象的父類基本影片。不同類型的影片類別實作抽象的父類基本影片。 ʕ •ᴥ•ʔ：一個簡單易懂的模式，背後隱藏了很多設計模式的原則。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"樣板方法模式","slug":"Template-Method-Pattern","date":"2020-08-02T10:26:46.000Z","updated":"2020-10-12T16:04:12.277Z","comments":true,"path":"2020/08/02/Template-Method-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/08/02/Template-Method-Pattern/","excerpt":"Template Method Pattern","text":"Template Method Pattern在一個方法中定義一個算法的骨架，而將一些步驟延遲到子類中。Example: 影片製作大師 樣板方法模式會將類別分為兩類：分別是**抽象規則類 (Abstract Class)與實體算法類 (Concrete Class)**。 抽象規則類負責定義流程，實體算法類則關心細節如何實現。也可以增加鉤子 (hook)，使子類更加容易客製化。 優點：可以讓主流程中，相同的部分共用，不同的部分產生變化。 缺點：會使子類受限於骨架。 與其他模式的比較：[簡單工廠模式]：簡單工廠模式，是一個迷你的樣板方法模式，它只提出了建造類別這個步驟。 [策略模式]：策略模式，可以是樣板方法模式中的某個步驟。 以上兩個模式都可以與樣板方法模式協作良好。 當需要在同一套流程中，有部分細節需要個別實現時，很可能就是使用樣板方法模式的時機。 ʕ •ᴥ•ʔ：感覺大部分的情境中，樣板方法模式都不會只是單獨出現。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：機器人廚師（命令模式）","slug":"Class-Diagram-Robot-Chef-Command-Pattern","date":"2020-07-28T23:36:04.000Z","updated":"2020-10-17T10:09:38.609Z","comments":true,"path":"2020/07/29/Class-Diagram-Robot-Chef-Command-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/07/29/Class-Diagram-Robot-Chef-Command-Pattern/","excerpt":"Class Diagram:Robot Chef (Command Pattern)","text":"Example: 機器人廚師 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：機器人廚師（命令模式）","slug":"Example-Robot-Chef-Command-Pattern","date":"2020-07-21T16:11:24.000Z","updated":"2020-10-03T07:58:31.557Z","comments":true,"path":"2020/07/22/Example-Robot-Chef-Command-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/07/22/Example-Robot-Chef-Command-Pattern/","excerpt":"Example:Robot Chef (Command Pattern)","text":"Pattern: 命令模式 Class Diagram: 機器人廚師 情境：這是一間牛排館，會根據客戶的訂單出菜 123456789101112131415161718192021222324&lt;?phpnamespace App\\CommandPattern\\WesternRestaurant;class Program&#123; /** * @param array $order * @return array */ public function makeOrder($order) &#123; $result = []; if (in_array('Filet Mignon', $order)) &#123; $result[] = '菲力牛排'; &#125; if (in_array('Sirloin Steak', $order)) &#123; $result[] = '沙朗牛排'; &#125; return $result; &#125;&#125; 隨著生日蒸蒸日上，老闆已經沒辦法同時處理客人點餐與煎牛排了（這是兩種職責）。 決定引進我們販賣的機器人廚師，讓他能專心在記下客人的需求。 需求一：老闆決定到外場服務，透過指令指揮內場的機器人廚師煎牛排 首先是機器人廚師的程式碼 12345678910111213141516171819202122&lt;?phpnamespace App\\CommandPattern\\WesternRestaurant\\Receiver;abstract class Chef&#123; /** * @return string */ public function cookFiletMignon() &#123; return '菲力牛排'; &#125; /** * @return string */ public function cookSirloinSteak() &#123; return '沙朗牛排'; &#125;&#125; 123456789&lt;?phpnamespace App\\CommandPattern\\WesternRestaurant\\Receiver;use App\\CommandPattern\\WesternRestaurant\\Receiver\\Chef;class RobotChefA extends Chef&#123;&#125; 123456789&lt;?phpnamespace App\\CommandPattern\\WesternRestaurant\\Receiver;use App\\CommandPattern\\WesternRestaurant\\Receiver\\Chef;class RobotChefB extends Chef&#123;&#125; 再定義出命令介面 12345678&lt;?phpnamespace App\\CommandPattern\\WesternRestaurant\\Contracts;interface Command&#123; public function execute();&#125; 需要的指令：煎菲力牛排、煎沙朗牛排 123456789101112131415161718192021222324252627&lt;?phpnamespace App\\CommandPattern\\WesternRestaurant;use App\\CommandPattern\\WesternRestaurant\\Contracts\\Command;use App\\CommandPattern\\WesternRestaurant\\Receiver\\Chef;class CookFiletMignonCommand implements Command&#123; /** * @var Chef */ protected $chef; public function __construct(Chef $chef) &#123; $this-&gt;chef = $chef; &#125; /** * @return string */ public function execute() &#123; return $this-&gt;chef-&gt;cookFiletMignon(); &#125;&#125; 123456789101112131415161718192021222324252627&lt;?phpnamespace App\\CommandPattern\\WesternRestaurant;use App\\CommandPattern\\WesternRestaurant\\Contracts\\Command;use App\\CommandPattern\\WesternRestaurant\\Receiver\\Chef;class CookSirloinSteakCommand implements Command&#123; /** * @param Chef */ protected $chef; public function __construct(Chef $chef) &#123; $this-&gt;chef = $chef; &#125; /** * @return string */ public function execute() &#123; return $this-&gt;chef-&gt;cookSirloinSteak(); &#125;&#125; 最後修改原本牛排館的程式 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\\CommandPattern\\WesternRestaurant;use App\\CommandPattern\\WesternRestaurant\\Receiver\\RobotChefA;use App\\CommandPattern\\WesternRestaurant\\Receiver\\RobotChefB;class Program&#123; /** * @param array $order * @return array */ public function makeOrder($order) &#123; $chefA = new RobotChefA(); $chefB = new RobotChefB(); $cookFiletMignonCommand = new cookFiletMignonCommand($chefA); $cookSirloinSteakCommand = new CookSirloinSteakCommand($chefB); $result = []; if (in_array('Filet Mignon', $order)) &#123; $result[] = $cookFiletMignonCommand-&gt;execute(); &#125; if (in_array('Sirloin Steak', $order)) &#123; $result[] = $cookSirloinSteakCommand-&gt;execute(); &#125; return $result; &#125;&#125; [角色對應關係]**調用者 (Invoker)**：老闆**接收者 (Receiver)**：機器人廚師**命令 (Command)**：煎牛排指令 \b[單一職責原則]我們將點餐與煎牛排視作兩種不同的職責。透過命令來聯繫兩者。 [開放封閉原則]當新增/修改需求時，不會動到所有程式碼。（比如：外場老闆不會知道烹調方式的改變、機器人不會知道當前餐廳的優惠） [依賴反轉原則]調用者依賴抽象的命令介面。命令實作抽象的命令介面。 此外命令模式還可以留下點餐紀錄，便於將來結帳、重做餐點呢。 ʕ •ᴥ•ʔ：使用命令模式的老闆，也隱含「人力」資源管理的味道。（指定誰做什麼餐點）","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"命令模式","slug":"Command-Pattern","date":"2020-07-20T00:44:01.000Z","updated":"2020-12-11T14:51:59.840Z","comments":true,"path":"2020/07/20/Command-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/07/20/Command-Pattern/","excerpt":"Command Pattern","text":"Command Pattern將請求封裝成對象，以便使用不同的請求來進行參數化。命令模式也支持隊列、日誌及可撤銷的操作。Example: 機器人廚師 命令模式會將類別分成三類：分別是**調用者 (Invoker)、接收者 (Receiver)及命令 (Command)**。 優點：容易滿足開放封閉原則（需要時新增命令即可）。若有需要，可將命令記錄至日誌中，便於重做 (redo) 及撤消 (undo)。允許接收者決定是否否決請求。 缺點：會做出許多小類別。 與其他模式的比較：[策略模式]：以四則運算來比喻的話，策略模式像是算法族中，有加減乘除四種算法；而命令模式則像是一段計算過程：加三、減五、乘二。每個運算都是一道命令。 ʕ •ᴥ•ʔ：透過將命令切分成類別，解耦了調用者（命令請求者）與接收者（命令執行者）的依賴關係。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：資料庫連線（單例模式）","slug":"Class-Diagram-DB-Connection-Singleton-Pattern","date":"2020-07-19T10:21:04.000Z","updated":"2020-10-16T18:05:50.888Z","comments":true,"path":"2020/07/19/Class-Diagram-DB-Connection-Singleton-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/07/19/Class-Diagram-DB-Connection-Singleton-Pattern/","excerpt":"Class Diagram:DB Connection (Singleton Pattern)","text":"Example: 資料庫連線 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：資料庫連線（單例模式）","slug":"Example-DB-Connection-Singleton-Pattern","date":"2020-07-16T15:07:01.000Z","updated":"2020-10-16T18:00:26.839Z","comments":true,"path":"2020/07/16/Example-DB-Connection-Singleton-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/07/16/Example-DB-Connection-Singleton-Pattern/","excerpt":"Example:DB Connection (Singleton Pattern)","text":"Pattern: 單例模式 Class Diagram: 資料庫連線 需求一：客戶想要能與資料庫連線的類別\b 12345678910&lt;?phpnamespace App\\SingletonPattern\\DBConnection;class DBConnection&#123; public function __construct() &#123; &#125;&#125; 1234567891011121314&lt;?phpnamespace App\\SingletonPattern\\DBConnection;class Program&#123; /** * @return DBConnection */ public function getDBConnection() &#123; return new DBConnection(); &#125;&#125; 需求二：客戶說希望能修改成只建立唯一的連線。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpnamespace App\\SingletonPattern\\DBConnection;class DBConnection&#123; private static $instance = null; /** * 僅有私有的建構函式，讓外界僅能以 getInstance() 呼叫 */ private function __construct() &#123; &#125; /** * 避免克隆後，生成兩個實例 */ private function __clone() &#123; &#125; /** * 避免反序列化後，生成兩個實例 */ private function __wakeup() &#123; &#125; /** * 透過公開的靜態方法取得實例 * * @return DBConnection */ public static function getInstance() &#123; if (static::$instance === null) &#123; static::$instance = new self(); &#125; return self::$instance; &#125;&#125; 1234567891011121314&lt;?phpnamespace App\\SingletonPattern\\DBConnection;class Program&#123; /** * @return DBConnection */ public function getDBConnection() &#123; return DBConnection::getInstance(); &#125;&#125; 在這裡我們一共用了兩個技巧： 透過公開的靜態方法，呼叫私有的建構函式，來保證 DBConnection 的唯一。 在 getInstance() 中，我們會判斷 $instance 是否為 null，才決定是否實例化，為單例模式中Lazy Initialization的形式。 單例模式還有以下其他形式（處理多線程）： Eager Initialization （類別 $instance 一開始就建立，PHP 貌似不支援） Synchronized（同步方法） Double-Checked Locking（雙重檢查加鎖） 在 PHP 中，web 環境的每一個 request 都是獨立的線程，而 cli 環境，則需裝 pthreads 才能實現多線程。 因為 PHP 鮮少使用多線程，算是巧妙地閃躲了單例模式的使用問題。將來有機會會以其他程式語言，再次撰寫相關範例。 ʕ •ᴥ•ʔ：看似簡單，背後卻有許多細節的反模式。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"單例模式","slug":"Singleton-Pattern","date":"2020-07-15T14:58:04.000Z","updated":"2020-10-15T14:39:13.656Z","comments":true,"path":"2020/07/15/Singleton-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/07/15/Singleton-Pattern/","excerpt":"Singleton Pattern","text":"Singleton Pattern確保一個類只有一個實例，並提供一個全局訪問點。Example: 資料庫連線 單例模式只會將類別分為一類，即**單例類別 (Singleton)**。 單例類別會管理實例的產生，並提供存取實例的方法。 優點：可以確保類別只有一個實例。可以提供全局訪問點。 缺點：違反單一職責原則。實現單例時，須考慮多線程問題。因其特殊性，單例模式不容易作測試。 與全域變數的比較：單例模式可以嚴格地控制客戶如何存取它及何時使用它，並且具有狀態（可在執行時發生改變）。 ʕ •ᴥ•ʔ：單例模式常被視為一種反模式 (anti-pattern)。很可能是設計模式中，唯一一個違反單一職責原則。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：漢堡點餐系統（裝飾者模式）","slug":"Class-Diagram-Burgers-Ordering-System-Decorator-Pattern","date":"2020-07-13T00:12:02.000Z","updated":"2020-11-18T14:46:20.009Z","comments":true,"path":"2020/07/13/Class-Diagram-Burgers-Ordering-System-Decorator-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/07/13/Class-Diagram-Burgers-Ordering-System-Decorator-Pattern/","excerpt":"Class Diagram:Burgers Ordering System (Decorator Pattern)","text":"Example: 漢堡點餐系統 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：漢堡點餐系統（裝飾者模式）","slug":"Example-Burgers-Ordering-System-Decorator-Pattern","date":"2020-07-11T16:16:22.000Z","updated":"2020-11-18T14:44:40.198Z","comments":true,"path":"2020/07/12/Example-Burgers-Ordering-System-Decorator-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/07/12/Example-Burgers-Ordering-System-Decorator-Pattern/","excerpt":"Example:Burgers Ordering System (Decorator Pattern)","text":"Pattern: 裝飾者模式 Class Diagram: 漢堡點餐系統 需求一：客戶想要一個漢堡點餐系統 12345678910111213141516&lt;?phpnamespace App\\DecoratorPattern\\Burger;class Program&#123; public function makeBigMac() &#123; return '大麥克：麵包、牛肉、生菜、沙拉、麵包、牛肉、起司、生菜、沙拉、麵包'; &#125; public function makeDoubleCheeseBurger() &#123; return '雙層牛肉吉事堡：麵包、酸菜、起司、牛肉、起司、牛肉、麵包'; &#125;&#125; 需求二：客戶想要點餐能夠客製化 (比如說：兩倍起司) 我們決定先嘗試實作大麥克的客製化 12345678910111213141516171819202122232425&lt;?phpnamespace App\\DecoratorPattern\\Burger;class Program&#123; protected $cheese = 'normal'; /** * @param array $demand */ public function customize($demand) &#123; $this-&gt;cheese = $demand['cheese']; &#125; public function makeBigMac() &#123; if ($this-&gt;cheese == 'double') &#123; return '大麥克：麵包、牛肉、生菜、沙拉、麵包、牛肉、兩倍起司、生菜、沙拉、麵包'; &#125; return '大麥克：麵包、牛肉、生菜、沙拉、麵包、牛肉、起司、生菜、沙拉、麵包'; &#125;&#125; 在完成後，卻發現了一些問題： 每當有配料客製化需求時，我們必須改變大麥克的實作，違反開放封閉原則。 不同的漢堡種類，客製化的過程會違反 DRY 原則。 新增漢堡種類時，我們可能要實作目前所有客製化的選項。 藉由以上幾點，我們知道漢堡的實作與配料客製化是兩個不同的職責。我們試著改用裝飾者模式實作。 首先定義食物介面 12345678&lt;?phpnamespace App\\DecoratorPattern\\Burger\\Contracts;interface Food&#123; public function getDescription();&#125; 接著定義抽象的漢堡類別，並實作食物介面 123456789101112131415&lt;?phpnamespace App\\DecoratorPattern\\Burger\\ConcreteComponent;use App\\DecoratorPattern\\Burger\\Contracts\\Food;abstract class Burger implements Food&#123; protected $name = '未知品項'; public function getDescription() &#123; return $this-&gt;name . '：'; &#125;&#125; 實作大麥克漢堡 12345678910&lt;?phpnamespace App\\DecoratorPattern\\Burger\\ConcreteComponent;use App\\DecoratorPattern\\Burger\\ConcreteComponent\\Burger;class BigMac extends Burger&#123; protected $name = '大麥克';&#125; 漢堡在裝飾者模式中屬於裝飾物件類別，也就是被裝飾者。 接著定義配料的抽象類別，也實作食物介面 12345678910111213141516171819202122232425&lt;?phpnamespace App\\DecoratorPattern\\Burger\\Decorator;use App\\DecoratorPattern\\Burger\\Contracts\\Food;abstract class Ingredient implements Food&#123; /** * @var Food */ protected $food; protected $name = '未知配料'; public function __construct(Food $food) &#123; $this-&gt;food = $food; &#125; public function getDescription() &#123; return $this-&gt;food-&gt;getDescription() . $this-&gt;name . '、'; &#125;&#125; 注意：Food包括漢堡類（被裝飾者）和配料類（裝飾者）。 而這邊__construct()與getDescription()方法的實作，晚點會透過它們來實現裝飾。 接著實作各式配料 12345678910&lt;?phpnamespace App\\DecoratorPattern\\Burger\\Decorator;use App\\DecoratorPattern\\Burger\\Decorator\\Ingredient;class Bread extends Ingredient&#123; protected $name = '麵包';&#125; 12345678910&lt;?phpnamespace App\\DecoratorPattern\\Burger\\Decorator;use App\\DecoratorPattern\\Burger\\Decorator\\Ingredient;class Beef extends Ingredient&#123; protected $name = '牛肉';&#125; 12345678910&lt;?phpnamespace App\\DecoratorPattern\\Burger\\Decorator;use App\\DecoratorPattern\\Burger\\Decorator\\Ingredient;class Lettuce extends Ingredient&#123; protected $name = '生菜';&#125; 12345678910&lt;?phpnamespace App\\DecoratorPattern\\Burger\\Decorator;use App\\DecoratorPattern\\Burger\\Decorator\\Ingredient;class Salad extends Ingredient&#123; protected $name = '沙拉';&#125; 12345678910&lt;?phpnamespace App\\DecoratorPattern\\Burger\\Decorator;use App\\DecoratorPattern\\Burger\\Decorator\\Ingredient;class Cheese extends Ingredient&#123; protected $name = '起司';&#125; 配料在裝飾者模式中屬於裝飾者類別，也就是裝飾者。 準備工作就緒，讓我們來做一個大麥克吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpnamespace App\\DecoratorPattern\\Burger;use App\\DecoratorPattern\\Burger\\ConcreteComponent\\BigMac;use App\\DecoratorPattern\\Burger\\Decorator\\Bread;use App\\DecoratorPattern\\Burger\\Decorator\\Beef;use App\\DecoratorPattern\\Burger\\Decorator\\Lettuce;use App\\DecoratorPattern\\Burger\\Decorator\\Cheese;use App\\DecoratorPattern\\Burger\\Decorator\\Salad;use App\\DecoratorPattern\\Burger\\Decorator\\Pickle;use App\\DecoratorPattern\\Burger\\Decorator\\Ingredient;class Program&#123; public function makeBigMac() &#123; $bigMac = new BigMac(); $topBread = new Bread($bigMac); $firstBeef = new Beef($topBread); $firstLettuce = new Lettuce($firstBeef); $firstSalad = new Salad($firstLettuce); $middleBread = new Bread($firstSalad); $secondBeef = new Beef($middleBread); $cheese = new Cheese($secondBeef); $secondLettuce = new Lettuce($cheese); $secondSalad = new Salad($secondLettuce); $bottomBread = new Bread($secondSalad); // 大麥克：麵包、牛肉、生菜、沙拉、麵包、牛肉、起司、生菜、沙拉、麵包 return $this-&gt;getBurgerDescription($bottomBread); &#125; /** * @param Ingredient $burger * @return string */ private function getBurgerDescription(Ingredient $burger) &#123; $result = $burger-&gt;getDescription(); return $this-&gt;subLastPunctuation($result); &#125; /** * 去除最後一個標點符號 * * @param string $string * @return string */ private function subLastPunctuation($string) &#123; return mb_substr($string, 0, mb_strlen($string, 'UTF-8') - 1, 'UTF-8'); &#125;&#125; 有用subLastPunctuation方法作文字修飾，可忽略。 透過Ingredient抽象類別的**__construct()包裝先前的類**，當我們使用getDescription()時便能夠一層一層地往內部呼叫，直到所有類別都被呼叫後，才動態產生所需的結果。 讓我們回到需求二：兩倍起司的客製化需求 我們先來改寫Ingredient抽象類別新增customize()與changeDefaultIfDemanded()來作客製化的需求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpnamespace App\\DecoratorPattern\\Burger\\Decorator;use App\\DecoratorPattern\\Burger\\Contracts\\Food;use ReflectionClass;abstract class Ingredient implements Food&#123; /** * @var Food */ protected $food; protected $name = '未知配料'; public function __construct(Food $food) &#123; $this-&gt;food = $food; &#125; public function getDescription() &#123; return $this-&gt;food-&gt;getDescription() . $this-&gt;name . '、'; &#125; /** * 讓最後一個裝飾者客製化自己外，也能客製化先前的裝飾者 * * @param array $demand * @return food */ public function customize($demand) &#123; $this-&gt;changeDefaultIfDemanded($demand); if ($this-&gt;food instanceof Ingredient) &#123; $this-&gt;food-&gt;customize($demand); &#125; return $this; &#125; /** * 我們會利用該配料名稱，當作客製化的設定 * * @param array $demand */ protected function changeDefaultIfDemanded($demand) &#123; $ingredientName = $this-&gt;getIngredientName(); if (isset($demand[$ingredientName])) &#123; $this-&gt;$ingredientName = $demand[$ingredientName]; &#125; &#125; /** * @return string */ private function getIngredientName() &#123; $reflectionClass = new ReflectionClass($this); return strtolower($reflectionClass-&gt;getShortName()); &#125;&#125; 注意：Food包括漢堡類（被裝飾者）和配料類（裝飾者）。customize()方法遇到Food為配料時，會往內部呼叫，直到所有配料都被呼叫。 changeDefaultIfDemanded()，可理解成demand有提到的配料才會作客製化，可忽略。 接著改寫 Cheese 類別 123456789101112131415161718192021&lt;?phpnamespace App\\DecoratorPattern\\Burger\\Decorator;use App\\DecoratorPattern\\Burger\\Decorator\\Ingredient;class Cheese extends Ingredient&#123; protected $name = '起司'; protected $cheese = 'normal'; public function getDescription() &#123; if ($this-&gt;cheese == 'double') &#123; return $this-&gt;food-&gt;getDescription() . '兩倍' . $this-&gt;name . '、'; &#125; return parent::getDescription(); &#125;&#125; 最後改寫 Program 的實作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phpnamespace App\\DecoratorPattern\\Burger;use App\\DecoratorPattern\\Burger\\ConcreteComponent\\BigMac;use App\\DecoratorPattern\\Burger\\Decorator\\Bread;use App\\DecoratorPattern\\Burger\\Decorator\\Beef;use App\\DecoratorPattern\\Burger\\Decorator\\Lettuce;use App\\DecoratorPattern\\Burger\\Decorator\\Cheese;use App\\DecoratorPattern\\Burger\\Decorator\\Salad;use App\\DecoratorPattern\\Burger\\Decorator\\Pickle;use App\\DecoratorPattern\\Burger\\Decorator\\Ingredient;class Program&#123; /** * @var array */ protected $demand = []; /** * @param array $demand */ public function setDemand($demand) &#123; $this-&gt;demand = $demand; &#125; /** * @return string */ public function makeBigMac() &#123; $bigMac = new BigMac(); $topBread = new Bread($bigMac); $firstBeef = new Beef($topBread); $firstLettuce = new Lettuce($firstBeef); $firstSalad = new Salad($firstLettuce); $middleBread = new Bread($firstSalad); $secondBeef = new Beef($middleBread); $cheese = new Cheese($secondBeef); $secondLettuce = new Lettuce($cheese); $secondSalad = new Salad($secondLettuce); $bottomBread = new Bread($secondSalad); return $this-&gt;getBurgerDescription($bottomBread); &#125; /** * 去除最後一個標點符號 * * @param string $string * @return string */ private function subLastPunctuation($string) &#123; return mb_substr($string, 0, mb_strlen($string, 'UTF-8') - 1, 'UTF-8'); &#125; /** * @param Ingredient $ingredient * @return string */ private function getBurgerDescription(Ingredient $ingredient) &#123; $result = $ingredient-&gt;customize($this-&gt;demand)-&gt;getDescription(); return $this-&gt;subLastPunctuation($result); &#125;&#125; \b[單一職責原則]我們將漢堡的實作與配料客製化視作兩種不同的職責。 [開放封閉原則]無論是新增漢堡種類、新增配料或客製化，我們都能夠僅改到小部分的程式碼。 [裡氏替換原則]遇到客製化需求時，我們可能會改寫配料中的getDescription()方法。 [介面隔離原則]食物介面 - 使每個食物能透過getDescription()方法組裝。漢堡抽象類別 - 被裝飾者，主要是為了與配料類（裝飾者）職責切割。配料抽象類別 - 裝飾者，擁有一些客製化的方法。 [依賴反轉原則]許多方法都依賴在食物介面、漢堡抽象類別、配料抽象類別。 ʕ •ᴥ•ʔ：這個Example有作testing ，被我refactor無數次，是目前為止最喜歡的範例！","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"裝飾者模式","slug":"Decorator-Pattern","date":"2020-07-11T16:14:24.000Z","updated":"2020-11-18T14:47:56.037Z","comments":true,"path":"2020/07/12/Decorator-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/07/12/Decorator-Pattern/","excerpt":"Decorator Pattern","text":"Decorator Pattern動態地將責任附加到對象上。若要擴展功能，裝飾者提供了比繼承更有彈性的替代方案。Example: 漢堡點餐系統 裝飾者模式會將類別分為兩類：分別是**裝飾物件類別 (ConcreteComponent)與裝飾者類別 (Decorator)**。 其中裝飾物件與裝飾者會實現相同的接口。 在裝飾物件類別不知道裝飾者的情況下，我們會在產生對象時，動態地將其一個個裝飾上去。 一般會透過建構函式來包裝先前的裝飾者。便於理解，裝飾物件即被裝飾者。 優點：當需要動態reuse寫好的類別方法時，裝飾者模式提供了用組合取代繼承的解決方案。（一種wrapping的委託技術） 職責切分明確，裝飾者類別僅需完成自己的方法，由客戶端決定執行順序。 缺點：程式碼複雜度提高。當方法不依賴執行順序時，無法用裝飾者模式實作。 與其他模式的比較：[策略模式]：以卡牌遊戲比喻的話，策略模式是決定要出哪張怪獸卡，而裝飾者模式則是在原有的怪獸卡上，加上裝備卡。 ʕ •ᴥ•ʔ：裝飾者模式專注在對象上，也就更能客製化需求。（動態產生對象，而不是子類）","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：收銀機（策略模式)","slug":"Class-Diagram-Cash-Register-Strategy-Pattern","date":"2020-07-06T14:38:50.000Z","updated":"2020-09-24T14:04:54.001Z","comments":true,"path":"2020/07/06/Class-Diagram-Cash-Register-Strategy-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/07/06/Class-Diagram-Cash-Register-Strategy-Pattern/","excerpt":"Class Diagram:Cash Register (Strategy Pattern)","text":"Example: 收銀機 注意 Program 跟 CashContext 的方法名只是恰好與 Payable \b&amp; Receiptable 中相同。 為了易於理解，並未列出所有細節。 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"範例：收銀機 （策略模式)","slug":"Example-Cash-Register-Strategy-Pattern","date":"2020-07-05T13:22:32.000Z","updated":"2020-09-23T16:45:50.389Z","comments":true,"path":"2020/07/05/Example-Cash-Register-Strategy-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/07/05/Example-Cash-Register-Strategy-Pattern/","excerpt":"Example:Cash Register (Strategy Pattern)","text":"Pattern: 策略模式 Class Diagram: 收銀機 需求一：客戶想要一台收銀機 123456789101112131415161718192021&lt;?phpnamespace App\\StrategyPattern\\CashRegister;class Program&#123; /** * @var int */ private $originalPrice; public function __construct($originalPrice) &#123; $this-&gt;originalPrice = $originalPrice; &#125; public function pay() &#123; return $this-&gt;originalPrice; &#125;&#125; 需求二：客戶想要有一個優惠活動 (打8折) 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\\StrategyPattern\\CashRegister;class Program&#123; /** * @var int */ private $originalPrice; /** * @var string */ private $promotion; public function __construct($originalPrice, $promotion) &#123; $this-&gt;originalPrice = $originalPrice; $this-&gt;promotion = $promotion; &#125; public function pay() &#123; if ($this-&gt;promotion == '20% off') &#123; return $this-&gt;originalPrice * 0.8; &#125; return $this-&gt;originalPrice; &#125;&#125; 需求三：客戶想要有另一個優惠 (買300回饋100) 身為工程師的我們，二話不說加上了這個功能 12345678910111213141516public function pay()&#123; $originalPrice = $this-&gt;originalPrice; if ($this-&gt;promotion == '20% off') &#123; return $originalPrice * 0.8; &#125; if ($this-&gt;promotion == 'spend_300_feedback_100') &#123; if ($originalPrice &gt;= 300) &#123; return $originalPrice - floor($originalPrice / 300) * 100; &#125; &#125; return $originalPrice;&#125; 這時候功能是完成了，但有沒有覺得哪裡怪怪的？欸嘿，我們想到之前學過的簡單工廠模式。 可以實作三個類別，分別是正常付費、8折付費、買300回饋100。讓我們利用簡單工廠改造它。 首先定義付錢介面 12345678&lt;?phpnamespace App\\StrategyPattern\\CashRegister\\Contracts;interface Payable&#123; public function pay();&#125; 實作正常付費類別 1234567891011121314151617181920212223&lt;?phpnamespace App\\StrategyPattern\\CashRegister;use App\\StrategyPattern\\CashRegister\\Contracts\\Payable;class NormalPay implements Payable&#123; /** * @var int */ private $originalPrice; public function __construct($originalPrice) &#123; $this-&gt;originalPrice = $originalPrice; &#125; public function pay() &#123; return $this-&gt;originalPrice; &#125;&#125; 實作打折付費類別 1234567891011121314151617181920212223242526272829&lt;?phpnamespace App\\StrategyPattern\\CashRegister;use App\\StrategyPattern\\CashRegister\\Contracts\\Payable;class OffPercentPay implements Payable&#123; /** * @var int */ private $originalPrice; /** * @var double */ private $offPercent; public function __construct($originalPrice, $offPercent) &#123; $this-&gt;originalPrice = $originalPrice; $this-&gt;offPercent = $offPercent; &#125; public function pay() &#123; return $this-&gt;originalPrice * (1 - $this-&gt;offPercent); &#125;&#125; 實作買多少回饋多少類別 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpnamespace App\\StrategyPattern\\CashRegister;use App\\StrategyPattern\\CashRegister\\Contracts\\Payable;class FeedbackPay implements Payable&#123; /** * @var int */ private $originalPrice; /** * @var int */ private $priceCondition; /** * @var int */ private $feedback; public function __construct($originalPrice, $priceCondition, $feedback) &#123; $this-&gt;originalPrice = $originalPrice; $this-&gt;priceCondition = $priceCondition; $this-&gt;feedback = $feedback; &#125; public function pay() &#123; $originalPrice = $this-&gt;originalPrice; $priceCondition = $this-&gt;priceCondition; $feedback = $this-&gt;feedback; if ($originalPrice &gt;= $priceCondition) &#123; return $originalPrice - floor($originalPrice / $priceCondition) * $feedback; &#125; return $originalPrice; &#125;&#125; 最後原本程式再搭配工廠即可完成。 (下略) 正當我們洋洋得意的時候，客戶送來第四個需求… 需求四：客戶希望收銀機可以開一般發票或電子發票 不是啊，客戶你要這種發票類型的需求你要先說.. (碎念) 按照簡單工廠模式的思維，我們必須為這個需求做出6個類別，分別是 （正常付費、打折付費、買多少回饋多少）x（一般發票、電子發票）的排列組合。 不行不行，假設客戶將來又提出要開統編的需求，我們就要寫8個類別了。 而且這樣也違反開放封閉原則。每次有新需求都會改動所有的程式碼。 在我們研究一下後，發現了一個適合的設計模式：策略模式 我們首先製作一個消費明細類別，它擁有所有的優惠方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpnamespace App\\StrategyPattern\\CashRegister;use App\\StrategyPattern\\CashRegister\\OffPercentPay;use App\\StrategyPattern\\CashRegister\\FeedbackPay;use App\\StrategyPattern\\CashRegister\\NormalPay;use App\\StrategyPattern\\CashRegister\\Contracts\\Payable;class CashContext&#123; /** * @var Payable */ private $discountMethod; /** * @param int $originalPrice * @param string $discountType */ public function __construct($originalPrice, $discountType) &#123; $this-&gt;resolveDiscountMethod($originalPrice, $discountType); &#125; /** * @param int $originalPrice * @param string $discountType */ private function resolveDiscountMethod($originalPrice, $discountType) &#123; switch ($discountType) &#123; case '20% off': $this-&gt;discountMethod = new OffPercentPay($originalPrice, 0.2); break; case 'spend_300_feedback_100': $this-&gt;discountMethod = new FeedbackPay($originalPrice, 300, 100); break; default: $this-&gt;discountMethod = new NormalPay($originalPrice); break; &#125; &#125; public function pay() &#123; return $this-&gt;discountMethod-&gt;pay(); &#125;&#125; 再來修改Program，讓它呼叫消費明細物件 123456789101112131415161718192021222324252627&lt;?phpnamespace App\\StrategyPattern\\CashRegister;use App\\StrategyPattern\\CashRegister\\CashContext;class Program&#123; /** * @var CashContext */ private $cashContext; /** * @param int $originalPrice * @param string $discountType */ public function __construct($originalPrice, $discountType) &#123; $this-&gt;cashContext = new CashContext($originalPrice, $discountType); &#125; public function pay() &#123; return $this-&gt;cashContext-&gt;pay(); &#125;&#125; 這樣好像還看不出來有什麼好處，我們繼續實作。 定義發票介面 12345678&lt;?phpnamespace App\\StrategyPattern\\CashRegister\\Contracts;interface Receiptable&#123; public function getReceipt();&#125; 實作一般發票 12345678910111213&lt;?phpnamespace App\\StrategyPattern\\CashRegister;use App\\StrategyPattern\\CashRegister\\Contracts\\Receiptable;class NormalReceipt implements Receiptable&#123; public function getReceipt() &#123; return '一般發票'; &#125;&#125; 實作電子發票 12345678910111213&lt;?phpnamespace App\\StrategyPattern\\CashRegister;use App\\StrategyPattern\\CashRegister\\Contracts\\Receiptable;class ElectronicReceipt implements Receiptable&#123; public function getReceipt() &#123; return '電子發票'; &#125;&#125; 修改消費明細類別 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?phpnamespace App\\StrategyPattern\\CashRegister;use App\\StrategyPattern\\CashRegister\\NormalPay;use App\\StrategyPattern\\CashRegister\\NormalReceipt;use App\\StrategyPattern\\CashRegister\\Contracts\\Payable;use App\\StrategyPattern\\CashRegister\\ElectronicReceipt;use App\\StrategyPattern\\CashRegister\\Contracts\\Receiptable;class CashContext&#123; /** * @var Payable */ private $discountMethod; /** * @var Receiptable */ private $receipt; /** * @param int $originalPrice * @param string $discountType * @param string $receiptType */ public function __construct($originalPrice, $discountType, $receiptType) &#123; $this-&gt;resolveDiscountMethod($originalPrice, $discountType); $this-&gt;resolveReceiptType($receiptType); &#125; /** * @param int $originalPrice * @param string $discountType */ private function resolveDiscountMethod($originalPrice, $discountType) &#123; switch ($discountType) &#123; case '20% off': $this-&gt;discountMethod = new OffPercentPay($originalPrice, 0.2); break; case 'spend_300_feedback_100': $this-&gt;discountMethod = new FeedbackPay($originalPrice, 300, 100); break; default: $this-&gt;discountMethod = new NormalPay($originalPrice); break; &#125; &#125; /** * @param string $receiptType */ private function resolveReceiptType($receiptType) &#123; switch ($receiptType) &#123; case 'electronicReceipt': $this-&gt;receipt = new ElectronicReceipt(); break; default: $this-&gt;receipt = new NormalReceipt(); break; &#125; &#125; public function pay() &#123; return $this-&gt;discountMethod-&gt;pay(); &#125; public function getReceipt() &#123; return $this-&gt;receipt-&gt;getReceipt(); &#125;&#125; 最後修改原本的Program 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\\StrategyPattern\\CashRegister;use App\\StrategyPattern\\CashRegister\\CashContext;class Program&#123; /** * @var CashContext */ private $cashContext; /** * @param int $originalPrice * @param string $discountType * @param string $receiptType */ public function __construct($originalPrice, $discountType, $receiptType) &#123; $this-&gt;cashContext = new CashContext($originalPrice, $discountType, $receiptType); &#125; public function pay() &#123; return $this-&gt;cashContext-&gt;pay(); &#125; public function getReceipt() &#123; return $this-&gt;cashContext-&gt;getReceipt(); &#125;&#125; [單一職責原則]將類別本身職責跟算法族的職責分離，就是策略模式的精神！ \b[開放封閉原則]這下子，我們終於不會在客戶提出一個新需求時，影響到全部的既有程式碼了。 [介面隔離原則]定義出付錢介面與發票介面，讓兩者不會互相影響。可以交由各自的算法族，分別實現。 [依賴反轉原則]消費明細類別依賴抽象的付錢介面與發票介面。不同的算法族，實現對應的抽象介面。 ʕ •ᴥ•ʔ：使用策略模式，我們依然會做出許多小類別（算法族/算法），但因為切分的更細，也就更能因應需求去做變化。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"策略模式","slug":"Strategy-Pattern","date":"2020-07-05T13:02:46.000Z","updated":"2020-11-22T14:42:17.329Z","comments":true,"path":"2020/07/05/Strategy-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/07/05/Strategy-Pattern/","excerpt":"Strategy Pattern","text":"Strategy Pattern定義算法族，分別封裝，讓彼此之間能互相替換，使算法變化獨立。Example: 收銀機 策略模式只會將類別分為一類，即**算法族類別 (Algorithm)**。 同一算法族類別會實作相同介面，便於替換。 優點：將物件本身的職責與算法的職責分離。新增/修改算法時，不會影響既有程式碼。具體算法組合交給客戶端，能在執行時才被決定。 缺點：會做出許多小類別。 與其他模式的比較：[簡單工廠模式]：在簡單工廠模式中，各個物件都已定義好其中的方法，而策略模式的精神則是執行時組合不同的演算法。 當需要在不同時間應用不同的業務規則時，很可能就是使用策略模式的時機。 ʕ •ᴥ•ʔ：將職責切分至算法族的層級，就是策略模式。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"類別圖：計算機（簡單工廠模式）","slug":"Class-Diagram-Calculator-Simple-Factory-Pattern","date":"2020-06-27T03:44:52.000Z","updated":"2020-07-26T12:13:03.412Z","comments":true,"path":"2020/06/27/Class-Diagram-Calculator-Simple-Factory-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/06/27/Class-Diagram-Calculator-Simple-Factory-Pattern/","excerpt":"Class Diagram:Calculator (Simple Factory Pattern)","text":"Example: 計算機 ʕ •ᴥ•ʔ：若不熟悉 UML 類別圖，可參考UML類別圖說明。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"UML類別圖說明","slug":"Class-Diagram-Description","date":"2020-06-26T03:38:55.000Z","updated":"2020-09-21T09:38:42.144Z","comments":true,"path":"2020/06/26/Class-Diagram-Description/","link":"","permalink":"https://yncbearz.github.io/2020/06/26/Class-Diagram-Description/","excerpt":"Class Diagram Description","text":"Class DiagramClass diagram describes the structure of a system by showing the system’s classes, their attributes, operations (or methods), and the relationships among objects. 類別圖描述了系統的類別集合，類別的屬性和類別之間的關係。 關聯 (Association) ：以實線箭頭表示。關聯關係使一個類別知道另外一個類別的屬性和方法；通常含有「知道」、「瞭解」的含義。 貓咪知道天氣情況 實作 (Implementation) ：以空心三角形的虛線箭頭表示。實作關係指的是一個 class 類別實現 interface 介面。 飛機實作可飛行介面 聚合 (Aggregation)：以空心菱形的實線表示。聚合關係是整體與部分的「弱」包含關係。部分類別可單獨存在，也可以屬於多個整體物件。 描述has-a的關係 學校包含學生、課堂包含學生 學生可以單獨存在 組成（Composition）：以實心菱形的實線表示。組成關係是整體與部分的「強」包含關係。部分類別無法單獨存在，其生命週期與整體相同。 描述contains-a的關係 手錶包含時針、時鐘包含時針 時針無法單獨存在 繼承 (Inheritance)：以空心三角形的實線箭頭表示。繼承關係指的是父類別擁有子類別的共有功能。而子類別可以視作父類別的特例。 描述is-a的關係 學生是人的特例、工程師是人的特例 ʕ •ᴥ•ʔ：學習Design Pattern的過程中，一定會遇到的圖形！寫完才發現，自己很少描述聚合跟組成的關係。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"}]},{"title":"KISS 原則","slug":"Keep-It-Simple-Stupid","date":"2020-06-25T08:13:10.000Z","updated":"2020-07-20T00:40:21.657Z","comments":true,"path":"2020/06/25/Keep-It-Simple-Stupid/","link":"","permalink":"https://yncbearz.github.io/2020/06/25/Keep-It-Simple-Stupid/","excerpt":"Keep It Simple, Stupid (KISS)","text":"Keep It Simple and Stupid (KISS) 保持簡單和愚蠢 讓程式碼保持簡單。 這樣做的優點是，任何人都能理解你的代碼，進而增加其生命週期 (可以被維護及複用)。 看似簡單的精神，卻需要許多努力才能實踐。 程式碼意圖表達性佳 適時的使用設計模式 Coding Style 貼近社群 其最終目的都是，減少程式碼的理解成本。 ʕ •ᴥ•ʔ：Kent Beck 實作模式中的核心精神，算是我第二喜歡的原則！","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://yncbearz.github.io/categories/Clean-Code/"}],"tags":[{"name":"Principle","slug":"Principle","permalink":"https://yncbearz.github.io/tags/Principle/"}]},{"title":"不要重複你自己","slug":"Dont-Repeat-Yourself","date":"2020-06-23T14:44:45.000Z","updated":"2020-06-23T15:31:19.194Z","comments":true,"path":"2020/06/23/Dont-Repeat-Yourself/","link":"","permalink":"https://yncbearz.github.io/2020/06/23/Dont-Repeat-Yourself/","excerpt":"Don't Repeat Yourself (DRY)","text":"Don’t Repeat Yourself (DRY)Every piece of knowledge must have a single, unambiguous, authoritative representation within a system. 系統中的每個部分，都必須要有唯一、明確且權威的代表。 在許多部分，有著重覆的程式碼，會造成將來修改時有所遺漏，透過遵守 DRY ，修改一處程式碼後，其餘地方便會同步改變。 不要用複製貼上編程法。(Copy-and-paste programming) 而違反 DRY 原則，又被戲稱為 WET“Write Every Time”“We Enjoy Typing” ʕ •ᴥ•ʔ：Avoid writing duplicate code !","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://yncbearz.github.io/categories/Clean-Code/"}],"tags":[{"name":"Principle","slug":"Principle","permalink":"https://yncbearz.github.io/tags/Principle/"}]},{"title":"範例：計算機 （簡單工廠模式)","slug":"Example-Calculator-Simple-Factory-Pattern","date":"2020-06-21T14:40:20.000Z","updated":"2020-10-12T15:54:41.392Z","comments":true,"path":"2020/06/21/Example-Calculator-Simple-Factory-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/06/21/Example-Calculator-Simple-Factory-Pattern/","excerpt":"Example:Calculator (Simple Factory Pattern)","text":"Pattern: 簡單工廠模式 Class Diagram: 計算機 需求一：客戶想要一個加法計算機 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\\FactoryPattern\\Calculator;class Program&#123; /** * @var int */ private $firstNumber; /** * @var int */ private $secondNumber; /** * @var string */ private $operationString; public function __construct($firstNumber, $secondNumber) &#123; $this-&gt;firstNumber = $firstNumber; $this-&gt;secondNumber = $secondNumber; &#125; public function run() &#123; return $this-&gt;firstNumber + $this-&gt;secondNumber; &#125;&#125; 需求二：客戶想要在既有的計算機上，增加減法功能 我們思路如下： 首先改變建構式，讓參數有運算符號 123456public function __construct($firstNumber, $secondNumber, $operationString)&#123; $this-&gt;firstNumber = $firstNumber; $this-&gt;secondNumber = $secondNumber; $this-&gt;operationString = $operationString;&#125; 由運算符號，執行對應的方法 1234567891011121314public function run()&#123; $operationString = $this-&gt;operationString; switch ($operationString) &#123; case '+': return $this-&gt;firstNumber + $this-&gt;secondNumber; break; case '-': return $this-&gt;firstNumber - $this-&gt;secondNumber; break; &#125;&#125; 需求三：客戶想要除法的功能 於是我們在函式中，再添加一個除法的功能 123456789101112131415161718192021public function run()&#123; $operationString = $this-&gt;operationString; switch ($operationString) &#123; case '+': return $this-&gt;firstNumber + $this-&gt;secondNumber; break; case '-': return $this-&gt;firstNumber - $this-&gt;secondNumber; break; case \"/\": if ($this-&gt;secondNumber === 0) &#123; return 'Division by zero'; &#125; return $this-&gt;firstNumber / $this-&gt;secondNumber; break; &#125;&#125; 這時候功能是完成了，但有沒有覺得哪裡怪怪的？ 除法的case很醜，要額外判斷除數不為0，增加了嵌套層數。 每當客戶要新增/修改/刪除一種運算時，其餘的運算都會被修改到。違反了開放封閉原則。 讓我們用簡單工廠改造它。 首先定義運算的介面 12345678&lt;?phpnamespace App\\FactoryPattern\\Calculator\\Contracts;interface Operable&#123; public function execute();&#125; 實作加法運算 12345678910111213141516&lt;?phpnamespace App\\FactoryPattern\\Calculator\\Operation;use App\\FactoryPattern\\Calculator\\Contracts\\Operable;class AddOperation implements Operable&#123; public $firstNumber; public $secondNumber; public function execute() &#123; return $this-&gt;firstNumber + $this-&gt;secondNumber; &#125;&#125; 實作減法運算 12345678910111213141516&lt;?phpnamespace App\\FactoryPattern\\Calculator\\Operation;use App\\FactoryPattern\\Calculator\\Contracts\\Operable;class MinusOperation implements Operable&#123; public $firstNumber; public $secondNumber; public function execute() &#123; return $this-&gt;firstNumber - $this-&gt;secondNumber; &#125;&#125; 實作除法運算 12345678910111213141516171819&lt;?phpnamespace App\\FactoryPattern\\Calculator\\Operation;use App\\FactoryPattern\\Calculator\\Contracts\\Operable;class DivideOperation implements Operable&#123; public $firstNumber; public $secondNumber; public function execute() &#123; if ($this-&gt;secondNumber === 0) &#123; return 'Division by zero'; &#125; return $this-&gt;firstNumber / $this-&gt;secondNumber; &#125;&#125; 最後做一個創造運算的工廠 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\\FactoryPattern\\Calculator;use App\\FactoryPattern\\Calculator\\Contracts\\Operable;use App\\FactoryPattern\\Calculator\\Operation\\AddOperation;use App\\FactoryPattern\\Calculator\\Operation\\MinusOperation;use App\\FactoryPattern\\Calculator\\Operation\\DivideOperation;class SimpleOperationFactory&#123; /** * @param string $operationString * @return Operable */ public function create($operationString): Operable &#123; switch ($operationString) &#123; case '+': return new AddOperation(); break; case '-': return new MinusOperation(); break; case '/': return new DivideOperation(); break; &#125; &#125;&#125; 修改原本的產品程式碼，讓運算由工廠產生 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpnamespace App\\FactoryPattern\\Calculator;use App\\FactoryPattern\\Calculator\\Contracts\\Operable;use App\\FactoryPattern\\Calculator\\SimpleOperationFactory;class Program&#123; /** * @var int */ private $firstNumber; /** * @var int */ private $secondNumber; /** * @var string */ private $operationString; /** * @var Operable */ private $operation; public function __construct($firstNumber, $secondNumber, $operationString) &#123; $this-&gt;firstNumber = $firstNumber; $this-&gt;secondNumber = $secondNumber; $this-&gt;operationString = $operationString; &#125; public function run() &#123; $simpleOperationFactory = new SimpleOperationFactory(); $this-&gt;operation = $simpleOperationFactory-&gt;create($this-&gt;operationString); return $this-&gt;execute(); &#125; /** * @return int|string */ private function execute() &#123; $this-&gt;operation-&gt;firstNumber = $this-&gt;firstNumber; $this-&gt;operation-&gt;secondNumber = $this-&gt;secondNumber; return $this-&gt;operation-&gt;execute(); &#125;&#125; 需求四：客戶想要乘法的功能 實作乘法運算 12345678910111213141516&lt;?phpnamespace App\\FactoryPattern\\Calculator\\Operation;use App\\FactoryPattern\\Calculator\\Contracts\\Operable;class MultiplyOperation implements Operable&#123; public $firstNumber; public $secondNumber; public function execute() &#123; return $this-&gt;firstNumber * $this-&gt;secondNumber; &#125;&#125; 修改運算工廠 123456789101112131415161718192021222324/** * @param string $operationString * @return Operable */public function create($operationString): Operable&#123; switch ($operationString) &#123; case '+': return new AddOperation(); break; case '-': return new MinusOperation(); break; case '/': return new DivideOperation(); break; case '*': return new MultiplyOperation(); break; &#125;&#125; [單一職責原則]將創造運算的職責跟運算本身的職責分離，就是工廠模式的精神！ \b[開放封閉原則]這下子，我們終於不會每次新增/修改/刪除一個運算時，影響到其餘所有運算了。 ʕ •ᴥ•ʔ：函式出現switch時，很可能就是使用工廠模式的時機。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"}]},{"title":"簡單工廠模式","slug":"Simple-Factory-Pattern","date":"2020-06-21T12:39:30.000Z","updated":"2020-10-12T15:53:18.690Z","comments":true,"path":"2020/06/21/Simple-Factory-Pattern/","link":"","permalink":"https://yncbearz.github.io/2020/06/21/Simple-Factory-Pattern/","excerpt":"Simple Factory Pattern","text":"Simple Factory Pattern又稱為靜態工廠，傳入不同的參數以取得不同的類別物件。Example: 計算機、運輸系統 簡單工廠模式會將類別分為兩類：分別是工廠類別 (Creator) 與**產品類別 (Product)**。 在簡單工廠模式中，通常只會有一個工廠，負責一種產品的創建。 優點：將創建物件的邏輯與物件本身的邏輯分離，符合單一職責原則。 缺點：因工廠負責產品族中所有產品的創建，當新增/修改產品時，無法遵守開放封閉原則。 簡單工廠模式適用於創建物件時，沒有複雜邏輯的情況。 ʕ •ᴥ•ʔ：創造物件就是工廠模式唯一的職責。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"設計模式目錄","slug":"Design-Pattern-Menu","date":"2020-06-21T12:21:04.000Z","updated":"2020-12-27T13:26:22.661Z","comments":true,"path":"2020/06/21/Design-Pattern-Menu/","link":"","permalink":"https://yncbearz.github.io/2020/06/21/Design-Pattern-Menu/","excerpt":"Design Pattern Menu","text":"Design Pattern Menu 模式 範例 簡單工廠模式 (Simple Factory Pattern) 計算機、運輸系統 工廠方法模式 (Factory Method Pattern) 運輸系統 抽象工廠模式 (Abstract Factory Pattern) 運輸系統 策略模式 (Strategy Pattern) 收銀機 裝飾者模式 (Decorator Pattern) 漢堡點餐系統 單例模式 (Singleton Pattern) 資料庫連線 命令模式 (Command Pattern) 機器人廚師 樣板方法模式 (Template Method Pattern) 影片製作大師 轉接頭模式 (Adapter Pattern) 才藝表演 外觀模式 (Facade Pattern) 自助餐餐廳 狀態模式 (State Pattern) 會員制 觀察者模式 (Observer Pattern) Line群組通知 迭代器模式 (Iterator Pattern) 歌曲排行 代理模式 (Proxy Pattern) 快取代理 原型模式 (Prototype Pattern) 三隻小豬 建造者模式 (Builder Pattern) 假期規劃 備忘錄模式 (Memento Pattern) 仿真Git 蠅量模式 (Flyweight Pattern) 文字積木 解譯器模式 (Interpreter Pattern) 摩斯電碼 組合模式 (Composite Pattern) 生物分類學 橋接模式 (Bridge Pattern) 十二生肖 職責鏈模式 (Chain Of Responsibility Pattern) 新產品開發 中介者模式 (Mediator Pattern) 打招呼 訪問者模式 (Visitor Pattern) 各國婚禮 ʕ •ᴥ•ʔ：會在這裡陸續更新！","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Menu","slug":"Menu","permalink":"https://yncbearz.github.io/tags/Menu/"}]},{"title":"依賴反轉原則","slug":"Dependency-Inversion-Principle","date":"2020-06-08T01:56:53.000Z","updated":"2020-09-21T02:49:15.797Z","comments":true,"path":"2020/06/08/Dependency-Inversion-Principle/","link":"","permalink":"https://yncbearz.github.io/2020/06/08/Dependency-Inversion-Principle/","excerpt":"Dependency Inversion Principle (DIP)","text":"Dependency Inversion Principle (DIP)High-level modules should not depend on low-level modules. Both should depend on abstractions 高階模組不應該依賴低階模組。它們都應該依賴抽象。 Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions. 抽象不應該依賴細節。細節應該依賴抽象。 Example: 電力系統 目的是把高階模組對低階模組的依賴解耦，改為高階模組依賴定義出的抽象介面，而由低階模組去實現介面。 其中的依賴關係被顛倒，使得低階模組依賴於高階的抽象介面。 Def. 發電：泛指從其它種類的能源轉換為電力的過程。 最初我們有一個電力系統，發電系統採用火力發電，之後再由輸電系統，配給各個用戶。 今天我們想要抽換發電系統，改為風力發電。卻發現原本的電力系統強耦合於火力發電，不易抽換。 透過定義出抽象的發電介面，我們可以讓電力系統依賴於發電介面，並讓火力發電、風力發電去實作發電介面。 因為依賴抽象化，未來就更容易抽換發電系統了。 ʕ •ᴥ•ʔ：重讀一次DIP發現重點在於，如何定義出足夠抽象的介面。","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://yncbearz.github.io/categories/Clean-Code/"}],"tags":[{"name":"Principle","slug":"Principle","permalink":"https://yncbearz.github.io/tags/Principle/"},{"name":"S.O.L.I.D","slug":"S-O-L-I-D","permalink":"https://yncbearz.github.io/tags/S-O-L-I-D/"}]},{"title":"介面隔離原則","slug":"Interface-Segregation-Principle","date":"2020-06-03T15:08:50.000Z","updated":"2020-09-19T16:25:56.954Z","comments":true,"path":"2020/06/03/Interface-Segregation-Principle/","link":"","permalink":"https://yncbearz.github.io/2020/06/03/Interface-Segregation-Principle/","excerpt":"Interface Segregation Principle (ISP)","text":"Interface Segregation Principle (ISP)No client should be forced to depend on methods it does not use. 客戶不應該依賴他們不使用的方法。 Example: 咖啡機 透過將龐大的介面，拆分成一個個的小介面，解開耦合，進而容易重構、修改及部署。 前陣子Johnny提出ISP的目的，是為了多型的實作，也是不錯的觀點。（註：小介面比較易於實作） Def. 全自動咖啡機：會自己磨粉、沖煮的咖啡機。 假使我們實作一個咖啡機介面，內有兩種方法，分別是磨粉及沖煮。 隨著對咖啡的興趣增加，我們可能會想玩摩卡壺。（註：摩卡壺為一種沖煮咖啡的器具） 這時會發現，原本咖啡機介面職責有點多。摩卡壺沒辦法實作咖啡機介面（不會磨粉）。 透過將介面拆分成：磨粉介面、沖煮介面，我們可以讓原本的全自動咖啡機改成實作這兩種介面。 而摩卡壺實作沖煮介面。 這下原本的煮咖啡程式，就可以寫好不修改了。 ʕ •ᴥ•ʔ：ISP不就是介面版本的單一職責原則嗎?（笑）","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://yncbearz.github.io/categories/Clean-Code/"}],"tags":[{"name":"Principle","slug":"Principle","permalink":"https://yncbearz.github.io/tags/Principle/"},{"name":"S.O.L.I.D","slug":"S-O-L-I-D","permalink":"https://yncbearz.github.io/tags/S-O-L-I-D/"}]},{"title":"裡氏替換原則","slug":"Liskov-Substitution-Principle","date":"2020-05-31T05:18:05.000Z","updated":"2020-09-19T08:17:50.388Z","comments":true,"path":"2020/05/31/Liskov-Substitution-Principle/","link":"","permalink":"https://yncbearz.github.io/2020/05/31/Liskov-Substitution-Principle/","excerpt":"Liskov Substitution Principle (LSP)","text":"Liskov Substitution Principle (LSP)Subtypes must be substitutable for their base types. 子類別必須要能替代它的父類別。 Example: 老爸餐廳 目前是以集合關係的角度來理解LSP。 實作上大致有兩個概念： 子類別的Input型態可以比父類別更寬鬆。 子類別的Output型態則需比父類別更為嚴謹。 這樣子類別才有取代父類別的可能。（既有行為正常） Def. 餐廳：顧客可以用金流換取餐點的地方。 舉個實際例子，假設你要繼承老爸的餐廳： [Input篇]原本顧客習慣的付款方式是現金，你可以另外提供信用卡來付款。這樣原本使用現金的顧客，依然能在你的店消費。 [Output篇]而顧客來到餐廳的目的是餐點，你可以提供漢堡、炸牛排、陽春麵等等。但必須要是餐點。 ʕ •ᴥ•ʔ：LSP背後就是集合論啊，數學系對這個原則備感親切。","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://yncbearz.github.io/categories/Clean-Code/"}],"tags":[{"name":"Principle","slug":"Principle","permalink":"https://yncbearz.github.io/tags/Principle/"},{"name":"S.O.L.I.D","slug":"S-O-L-I-D","permalink":"https://yncbearz.github.io/tags/S-O-L-I-D/"}]},{"title":"開放封閉原則","slug":"Open-Close-Principle","date":"2020-05-30T06:44:40.000Z","updated":"2020-09-07T06:32:55.357Z","comments":true,"path":"2020/05/30/Open-Close-Principle/","link":"","permalink":"https://yncbearz.github.io/2020/05/30/Open-Close-Principle/","excerpt":"Open-Close Principle (OCP)","text":"Open-Close Principle (OCP)A software artifact should be open for extension but closed for modification. 一個軟體製品應該對於擴展是開放的，但對於修改是封閉的。 OCP是系統架構背後的推動力之一。目標是使系統易於擴展而不會因修改而產生較大的影響。 問：遵守單一職責原則會有什麼好處？答：你就可以遵守開放封閉原則囉（笑） 職責拆分與抽象化，便是這個原則的核心精神。其影響力無遠弗屆，從模組、類別到方法都能見其身影。 當你因為需求變更而修改到既有程式碼時，很有可能就會違反OCP。（比違反SRP容易察覺） 這是之前，在讀S.O.L.I.D時比較困惑的原則，實務情境不知道該如何遵守OCP。 目前理解的流程： 先清楚各個程式碼區塊，所負責的任務是什麼。 接著拆分職責，定義抽象的介面。 最後考慮架構，理解何時可以修改既有程式碼、何時應該新增程式碼。 SRP跟OCP是我心中最重要的兩個原則，相比之下，其他原則都像是他倆的補充說明。 ʕ •ᴥ•ʔ：定義好各個程式碼區塊的職責，然後遵守它。","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://yncbearz.github.io/categories/Clean-Code/"}],"tags":[{"name":"Principle","slug":"Principle","permalink":"https://yncbearz.github.io/tags/Principle/"},{"name":"S.O.L.I.D","slug":"S-O-L-I-D","permalink":"https://yncbearz.github.io/tags/S-O-L-I-D/"}]},{"title":"單一職責原則","slug":"Single-Responsibility-Principle","date":"2020-05-27T16:00:33.000Z","updated":"2021-01-01T12:33:02.019Z","comments":true,"path":"2020/05/28/Single-Responsibility-Principle/","link":"","permalink":"https://yncbearz.github.io/2020/05/28/Single-Responsibility-Principle/","excerpt":"Single Responsibility Principle (SRP)","text":"Single Responsibility Principle (SRP)A module should have one, and only one, reason to change. 一個模組應當有一個，且只有一個會改變的理由。 如果不好理解其定義的話，在Clean Architecture中有提到其最終版為，一個模組應當只對唯一的一個角色負責。 其影響力無遠弗屆，從模組、類別到方法都能見其身影。 討論code的時候，需要先建立彼此的共識。理解對方對code職責的定義，往往是很有幫助的。 這段Code的職責在你的定義下是做什麼的？用來解決什麼問題？它的服務對象是誰？任務目標是什麼？ 最近讀Refactoring時，討論到變數命名時，應只被設定一次。Kyo提出，這不就是變數的單一職責原則嗎？ ʕ •ᴥ•ʔ：所有Clean Code的原點，也是我最喜歡的原則。","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://yncbearz.github.io/categories/Clean-Code/"}],"tags":[{"name":"Principle","slug":"Principle","permalink":"https://yncbearz.github.io/tags/Principle/"},{"name":"S.O.L.I.D","slug":"S-O-L-I-D","permalink":"https://yncbearz.github.io/tags/S-O-L-I-D/"}]}],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://yncbearz.github.io/categories/Algorithm/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://yncbearz.github.io/categories/Design-Pattern/"},{"name":"Clean Code","slug":"Clean-Code","permalink":"https://yncbearz.github.io/categories/Clean-Code/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yncbearz.github.io/tags/LeetCode/"},{"name":"Note","slug":"Note","permalink":"https://yncbearz.github.io/tags/Note/"},{"name":"SQL","slug":"SQL","permalink":"https://yncbearz.github.io/tags/SQL/"},{"name":"Class Diagram","slug":"Class-Diagram","permalink":"https://yncbearz.github.io/tags/Class-Diagram/"},{"name":"Example","slug":"Example","permalink":"https://yncbearz.github.io/tags/Example/"},{"name":"Principle","slug":"Principle","permalink":"https://yncbearz.github.io/tags/Principle/"},{"name":"Menu","slug":"Menu","permalink":"https://yncbearz.github.io/tags/Menu/"},{"name":"S.O.L.I.D","slug":"S-O-L-I-D","permalink":"https://yncbearz.github.io/tags/S-O-L-I-D/"}]}